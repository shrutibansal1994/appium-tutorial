'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _teen_process = require('teen_process');

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _helpersJs = require('../helpers.js');

var _appiumSupport = require('appium-support');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _xmldom = require('xmldom');

var _xmldom2 = _interopRequireDefault(_xmldom);

var _xpath = require('xpath');

var _xpath2 = _interopRequireDefault(_xpath);

var manifestMethods = {};

// android:process= may be defined in AndroidManifest.xml
// http://developer.android.com/reference/android/R.attr.html#process
// note that the process name when used with ps must be truncated to the last 15 chars
// ps -c com.example.android.apis becomes ps -c le.android.apis
manifestMethods.processFromManifest = function callee$0$0(localApk) {
  var args, _ref, stdout, result, lines, applicationRegex, applicationFound, attributeRegex, processRegex, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, line, notAttribute, _process;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'].info("Retrieving process from manifest");
        args = ['dump', 'xmltree', localApk, 'AndroidManifest.xml'];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, args));

      case 6:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        result = null;
        lines = stdout.split("\n");
        applicationRegex = new RegExp(/\s+E: application \(line=\d+\).*/);
        applicationFound = false;
        attributeRegex = new RegExp(/\s+A: .+/);
        processRegex = new RegExp(/\s+A: android:process\(0x01010011\)="([^"]+).*"/);
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 17;
        _iterator = _getIterator(lines);

      case 19:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 36;
          break;
        }

        line = _step.value;

        if (applicationFound) {
          context$1$0.next = 25;
          break;
        }

        if (applicationRegex.test(line)) {
          applicationFound = true;
        }
        context$1$0.next = 33;
        break;

      case 25:
        notAttribute = !attributeRegex.test(line);

        if (!notAttribute) {
          context$1$0.next = 28;
          break;
        }

        return context$1$0.abrupt('break', 36);

      case 28:
        _process = processRegex.exec(line);

        if (!(_process && _process.length > 1)) {
          context$1$0.next = 33;
          break;
        }

        result = _process[1];
        // must trim to last 15 for android's ps binary
        if (result.length > 15) {
          result = result.substr(result.length - 15);
        }
        return context$1$0.abrupt('break', 36);

      case 33:
        _iteratorNormalCompletion = true;
        context$1$0.next = 19;
        break;

      case 36:
        context$1$0.next = 42;
        break;

      case 38:
        context$1$0.prev = 38;
        context$1$0.t0 = context$1$0['catch'](17);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 42:
        context$1$0.prev = 42;
        context$1$0.prev = 43;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 45:
        context$1$0.prev = 45;

        if (!_didIteratorError) {
          context$1$0.next = 48;
          break;
        }

        throw _iteratorError;

      case 48:
        return context$1$0.finish(45);

      case 49:
        return context$1$0.finish(42);

      case 50:
        return context$1$0.abrupt('return', result);

      case 51:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[17, 38, 42, 50], [43,, 45, 49]]);
};

/**
 * @typedef {Object} APKInfo
 * @property {string} apkPackage - The name of application package, for example 'com.acme.app'.
 * @property {string} apkActivity - The name of main application activity.
 */

/**
* Extract package and main activity name from application manifest using
* the custom apk tools.
*
* @param {string} localApk - The full path to application package.
* @param {string} aaptPath - The full path to appt binary.
* @param {string} jarPath - The full path to appium_apk_tools.jar utility
* @param {string} tmpRoot - The full path to the class-wide temporary folder.
* @return {APKInfo} The parsed application info.
* @throws {Error} If there was an error while getting the data from the given
*                 application package.
*/
function extractApkInfoWithApkTools(localApk, aaptPath, jarPath, tmpRoot) {
  var args, stdout, apkPackage, apkActivity, outputPath, getLaunchActivity, output, act;
  return _regeneratorRuntime.async(function extractApkInfoWithApkTools$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info("Extracting package and launch activity from manifest");
        args = ['dump', 'badging', localApk];
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(aaptPath, args));

      case 4:
        stdout = context$1$0.sent.stdout;
        apkPackage = new RegExp(/package: name='([^']+)'/g).exec(stdout);

        if (!(!apkPackage || apkPackage.length < 2)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Cannot parse package name from ' + ('\'' + _lodash2['default'].join([aaptPath, 'dump', 'badging', '"' + localApk + '"'], ' ') + '\' command  output'));

      case 8:
        apkPackage = apkPackage[1];
        apkActivity = new RegExp(/launchable-activity: name='([^']+)'/g).exec(stdout);

        if (!(apkActivity && apkActivity.length >= 2)) {
          context$1$0.next = 13;
          break;
        }

        apkActivity = apkActivity[1];
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 13:
        outputPath = _path2['default'].resolve(tmpRoot, apkPackage);
        getLaunchActivity = ['-jar', jarPath, 'printLaunchActivity', localApk, outputPath];
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('java', getLaunchActivity));

      case 17:
        output = context$1$0.sent;

        if (!output.stderr) {
          context$1$0.next = 20;
          break;
        }

        throw new Error('Cannot parse launchActivity from manifest: ' + output.stderr);

      case 20:
        stdout = output.stdout;
        act = new RegExp(/Launch activity parsed:([^']+)/g).exec(stdout);

        if (!(act && act.length >= 2)) {
          context$1$0.next = 25;
          break;
        }

        apkActivity = act[1];
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 25:
        throw new Error('Cannot parse main activity name from \'' + stdout + '\' command  output');

      case 26:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Extract package and main activity name from application manifest using
 * apkanalyzer tool.
 *
 * @param {string} localApk - The full path to application package.
 * @param {string} apkanalyzerPath - The full path to apkanalyzer tool.
 * @return {APKInfo} The parsed application info.
 * @throws {Error} If there was an error while getting the data from the given
 *                 application package or if the tool itself
 *                 is not present on the local file system.
 */
function extractApkInfoWithApkanalyzer(localApk, apkanalyzerPath) {
  var args, manifestXml, doc, apkPackageAttribute, apkPackage, apkActivityAttribute, apkActivity;
  return _regeneratorRuntime.async(function extractApkInfoWithApkanalyzer$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        args = ['-h', 'manifest', 'print', localApk];

        _loggerJs2['default'].debug('Starting \'' + apkanalyzerPath + '\' with args ' + JSON.stringify(args));
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(apkanalyzerPath, args, {
          shell: true,
          cwd: _path2['default'].dirname(apkanalyzerPath)
        }));

      case 4:
        manifestXml = context$1$0.sent.stdout;
        doc = new _xmldom2['default'].DOMParser().parseFromString(manifestXml);
        apkPackageAttribute = _xpath2['default'].select1('//manifest/@package', doc);

        if (apkPackageAttribute) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Cannot parse package name from ' + manifestXml);

      case 9:
        apkPackage = apkPackageAttribute.value;
        apkActivityAttribute = _xpath2['default'].select1("//application/*[starts-with(name(), 'activity') " + "and .//action[@*[local-name()='name' and .='android.intent.action.MAIN']] " + "and .//category[@*[local-name()='name' and .='android.intent.category.LAUNCHER']]]" + "/@*[local-name()='name']", doc);

        if (apkActivityAttribute) {
          context$1$0.next = 13;
          break;
        }

        throw new Error('Cannot parse main activity name from ' + manifestXml);

      case 13:
        apkActivity = apkActivityAttribute.value;
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Extract package and main activity name from application manifest.
 *
 * @param {string} localApk - The full path to application package.
 * @return {APKInfo} The parsed application info.
 * @throws {error} If there was an error while getting the data from the given
 *                 application package.
 */
manifestMethods.packageAndLaunchActivityFromManifest = function callee$0$0(localApk) {
  var apkInfoGetters, savedError, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, infoGetter, _ref2, apkPackage, apkActivity;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        apkInfoGetters = [function callee$1$0() {
          var apkanalyzerPath;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _helpersJs.getApkanalyzerForOs)(this));

              case 2:
                apkanalyzerPath = context$2$0.sent;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(extractApkInfoWithApkanalyzer(localApk, apkanalyzerPath));

              case 5:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 6:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.initAapt());

              case 2:
                context$2$0.next = 4;
                return _regeneratorRuntime.awrap(extractApkInfoWithApkTools(localApk, this.binaries.aapt, this.jars['appium_apk_tools.jar'], this.tmpDir));

              case 4:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }];
        savedError = undefined;
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 5;
        _iterator2 = _getIterator(apkInfoGetters);

      case 7:
        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
          context$1$0.next = 27;
          break;
        }

        infoGetter = _step2.value;
        context$1$0.prev = 9;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap(infoGetter());

      case 12:
        _ref2 = context$1$0.sent;
        apkPackage = _ref2.apkPackage;
        apkActivity = _ref2.apkActivity;

        _loggerJs2['default'].info('Package name: \'' + apkPackage + '\'');
        _loggerJs2['default'].info('Main activity name: \'' + apkActivity + '\'');
        return context$1$0.abrupt('return', { apkPackage: apkPackage, apkActivity: apkActivity });

      case 20:
        context$1$0.prev = 20;
        context$1$0.t0 = context$1$0['catch'](9);

        if (infoGetter !== _lodash2['default'].last(apkInfoGetters)) {
          _loggerJs2['default'].info('Using the alternative activity name detection method ' + ('because of: ' + context$1$0.t0.message));
        }
        savedError = context$1$0.t0;

      case 24:
        _iteratorNormalCompletion2 = true;
        context$1$0.next = 7;
        break;

      case 27:
        context$1$0.next = 33;
        break;

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](5);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t1;

      case 33:
        context$1$0.prev = 33;
        context$1$0.prev = 34;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 36:
        context$1$0.prev = 36;

        if (!_didIteratorError2) {
          context$1$0.next = 39;
          break;
        }

        throw _iteratorError2;

      case 39:
        return context$1$0.finish(36);

      case 40:
        return context$1$0.finish(33);

      case 41:
        throw new Error('packageAndLaunchActivityFromManifest failed. ' + ('Original error: ' + savedError.message) + (savedError.stderr ? '; StdErr: ' + savedError.stderr : ''));

      case 42:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 29, 33, 41], [9, 20], [34,, 36, 40]]);
};

/**
 * Extract target SDK version from application manifest.
 *
 * @param {string} localApk - The full path to application package.
 * @return {number} The version of the target SDK.
 * @throws {error} If there was an error while getting the data from the given
 *                 application package.
 */
manifestMethods.targetSdkVersionFromManifest = function callee$0$0(localApk) {
  var args, output, _ref3, stdout, targetSdkVersion;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'].info("Extracting package and launch activity from manifest");
        args = ['dump', 'badging', localApk];
        output = undefined;
        context$1$0.prev = 5;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, args));

      case 8:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;

        output = stdout;
        context$1$0.next = 16;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](5);
        throw new Error('fetching targetSdkVersion from local APK failed. Original error: ' + context$1$0.t0.message);

      case 16:
        targetSdkVersion = new RegExp(/targetSdkVersion:'([^']+)'/g).exec(output);

        if (targetSdkVersion) {
          context$1$0.next = 19;
          break;
        }

        throw new Error('targetSdkVersion is not specified in the application.');

      case 19:
        return context$1$0.abrupt('return', parseInt(targetSdkVersion[1], 10));

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 13]]);
};

/**
 * Extract target SDK version from package information.
 *
 * @param {string} pkg - The class name of the package installed on the device under test.
 * @return {number} The version of the target SDK.
 */
manifestMethods.targetSdkVersionUsingPKG = function callee$0$0(pkg) {
  var stdout, targetSdkVersion;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.shell(['dumpsys', 'package', pkg]));

      case 2:
        stdout = context$1$0.sent;
        targetSdkVersion = new RegExp(/targetSdk=([^\s\s]+)/g).exec(stdout);

        if (targetSdkVersion && targetSdkVersion.length >= 2) {
          targetSdkVersion = targetSdkVersion[1];
        } else {
          // targetSdk not found in the dump, assigning 0 to targetSdkVersion
          targetSdkVersion = 0;
        }
        return context$1$0.abrupt('return', parseInt(targetSdkVersion, 10));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Create binary representation of package manifest (usually AndroidManifest.xml).
 * `${manifest}.apk` file will be created as the result of this method
 * containing the compiled manifest.
 *
 * @param {string} manifest - Full path to the initial manifest template
 * @param {string} manifestPackage - The name of the manifest package
 * @param {string} targetPackage - The name of the destination package
 */
manifestMethods.compileManifest = function callee$0$0(manifest, manifestPackage, targetPackage) {
  var _ref4, platform, platformPath;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Compiling manifest ' + manifest);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _helpersJs.getAndroidPlatformAndPath)());

      case 3:
        _ref4 = context$1$0.sent;
        platform = _ref4.platform;
        platformPath = _ref4.platformPath;

        if (platform) {
          context$1$0.next = 8;
          break;
        }

        throw new Error("Required platform doesn't exist (API level >= 17)");

      case 8:
        _loggerJs2['default'].debug('Compiling manifest.');
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 11:
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['package', '-M', manifest, '--rename-manifest-package', manifestPackage, '--rename-instrumentation-target-package', targetPackage, '-I', _path2['default'].resolve(platformPath, 'android.jar'), '-F', manifest + '.apk', '-f']));

      case 14:
        _loggerJs2['default'].debug("Compiled manifest");
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](11);
        throw new Error('Error compiling manifest. Original error: ' + context$1$0.t0.message);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 17]]);
};

/**
 * Replace/insert the specially precompiled manifest file into the
 * particular package.
 *
 * @param {string} manifest - Full path to the precompiled manifest
 *                            created by `compileManifest` method call
 *                            without .apk extension
 * @param {string} srcApk - Full path to the existing valid application package, where
 *                          this manifest has to be insetred to. This package
 *                          will NOT be modified.
 * @param {string} dstApk - Full path to the resulting package.
 *                          The file will be overriden if it already exists.
 */
manifestMethods.insertManifest = function callee$0$0(manifest, srcApk, dstApk) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Inserting manifest, src: ' + srcApk + ' dst: ' + dstApk);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _helpersJs.unzipFile)(manifest + '.apk'));

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.copyFile(srcApk, dstApk));

      case 7:
        _loggerJs2['default'].debug("Testing new tmp apk");
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap((0, _helpersJs.assertZipArchive)(dstApk));

      case 10:
        _loggerJs2['default'].debug("Moving manifest");
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['remove', dstApk, _path2['default'].basename(manifest)]));

      case 14:
        context$1$0.next = 18;
        break;

      case 16:
        context$1$0.prev = 16;
        context$1$0.t0 = context$1$0['catch'](11);

      case 18:
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['add', dstApk, _path2['default'].basename(manifest)], { cwd: _path2['default'].dirname(manifest) }));

      case 20:
        _loggerJs2['default'].debug("Inserted manifest.");

      case 21:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 16]]);
};

/**
 * Check whether package manifest contains Internet permissions.
 *
 * @param {string} localApk - The full path to application package.
 * @return {boolean} True if the manifest requires Internet access permission.
 */
manifestMethods.hasInternetPermissionFromManifest = function callee$0$0(localApk) {
  var _ref5, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'].debug('Checking if \'' + localApk + '\' requires internet access permission in the manifest');
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['dump', 'badging', localApk]));

      case 6:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;
        return context$1$0.abrupt('return', new RegExp(/uses-permission:.*'android.permission.INTERNET'/).test(stdout));

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('Cannot check if \'' + localApk + '\' requires internet access permission. ' + ('Original error: ' + context$1$0.t0.message));

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 11]]);
};

/*
 * Prints out the manifest extracted from the apk
 *
 * @param {string} localApk - The full path to application package.
 * @param {?string} logLevel - The level at which to log. E.g., 'debug'
 */
manifestMethods.printManifestFromApk = function printManifestFromApk(localApk) {
  var logLevel = arguments.length <= 1 || arguments[1] === undefined ? 'debug' : arguments[1];

  var out, _ref6, stdout, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, line;

  return _regeneratorRuntime.async(function printManifestFromApk$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.initAapt());

      case 2:
        _loggerJs2['default'][logLevel]('Android manifest extracted from \'' + localApk + '\'');
        out = false;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.aapt, ['l', '-a', localApk]));

      case 6:
        _ref6 = context$1$0.sent;
        stdout = _ref6.stdout;
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 11;

        for (_iterator3 = _getIterator(stdout.split('\n')); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          line = _step3.value;

          if (!out && line.includes('Android manifest:')) {
            out = true;
          }
          if (out) {
            _loggerJs2['default'][logLevel](line);
          }
        }
        context$1$0.next = 19;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](11);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 19:
        context$1$0.prev = 19;
        context$1$0.prev = 20;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 22:
        context$1$0.prev = 22;

        if (!_didIteratorError3) {
          context$1$0.next = 25;
          break;
        }

        throw _iteratorError3;

      case 25:
        return context$1$0.finish(22);

      case 26:
        return context$1$0.finish(19);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 15, 19, 27], [20,, 22, 26]]);
};

exports['default'] = manifestMethods;
module.exports = exports['default'];

// process must be an attribute after application.

// this is an application attribute process.

// Look for activity or activity-alias with
// action == android.intent.action.MAIN and
// category == android.intent.category.LAUNCHER
// descendants
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hbmRyb2lkLW1hbmlmZXN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs0QkFBcUIsY0FBYzs7d0JBQ25CLGNBQWM7Ozs7eUJBRU0sZUFBZTs7NkJBQ2hDLGdCQUFnQjs7c0JBQ3JCLFFBQVE7Ozs7b0JBQ0wsTUFBTTs7OztzQkFDSixRQUFROzs7O3FCQUNULE9BQU87Ozs7QUFFekIsSUFBSSxlQUFlLEdBQUcsRUFBRSxDQUFDOzs7Ozs7QUFNekIsZUFBZSxDQUFDLG1CQUFtQixHQUFHLG9CQUFnQixRQUFRO01BR3hELElBQUksUUFDSCxNQUFNLEVBQ1AsTUFBTSxFQUNOLEtBQUssRUFDTCxnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxZQUFZLGtGQUNQLElBQUksRUFNTCxZQUFZLEVBS1osUUFBTzs7Ozs7O3lDQXJCVCxJQUFJLENBQUMsUUFBUSxFQUFFOzs7QUFDckIsOEJBQUksSUFBSSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7QUFDekMsWUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUscUJBQXFCLENBQUM7O3lDQUMxQyx3QkFBSyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7Ozs7QUFBOUMsY0FBTSxRQUFOLE1BQU07QUFDUCxjQUFNLEdBQUcsSUFBSTtBQUNiLGFBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUMxQix3QkFBZ0IsR0FBRyxJQUFJLE1BQU0sQ0FBQyxrQ0FBa0MsQ0FBQztBQUNqRSx3QkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLHNCQUFjLEdBQUcsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDO0FBQ3ZDLG9CQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsaURBQWlELENBQUM7Ozs7O2lDQUMvRCxLQUFLOzs7Ozs7OztBQUFiLFlBQUk7O1lBQ04sZ0JBQWdCOzs7OztBQUNuQixZQUFJLGdCQUFnQixD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QUFRRixlQUFlLENBQUMsb0JBQW9CLEdBQUcsU0FBZSxvQkFBb0IsQ0FBRSxRQUFRO01BQUUsUUFBUSx5REFBRyxPQUFPOztNQUdsRyxHQUFHLFNBQ0EsTUFBTSx1RkFDRixJQUFJOzs7Ozs7eUNBSlQsSUFBSSxDQUFDLFFBQVEsRUFBRTs7O0FBQ3JCLDhCQUFJLFFBQVEsQ0FBQyx3Q0FBcUMsUUFBUSxRQUFJLENBQUM7QUFDM0QsV0FBRyxHQUFHLEtBQUs7O3lDQUNRLHdCQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQzs7OztBQUEvRCxjQUFNLFNBQU4sTUFBTTs7Ozs7O0FBQ2IsdUNBQW1CLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLHlHQUFFO0FBQTVCLGNBQUk7O0FBQ2IsY0FBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLEVBQUU7QUFDOUMsZUFBRyxHQUFHLElBQUksQ0FBQztXQUNaO0FBQ0QsY0FBSSxHQUFHLEVBQUU7QUFDUCxrQ0FBSSxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztXQUNyQjtTQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FDRixDQUFDOztxQkFHYSxlQUFlIiwiZmlsZSI6ImxpYi90b29scy9hbmRyb2lkLW1hbmlmZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgbG9nIGZyb20gJy4uL2xvZ2dlci5qcyc7XG5pbXBvcnQgeyBnZXRBbmRyb2lkUGxhdGZvcm1BbmRQYXRoLCB1bnppcEZpbGUsIGFzc2VydFppcEFyY2hpdmUsXG4gICAgICAgICBnZXRBcGthbmFseXplckZvck9zIH0gZnJvbSAnLi4vaGVscGVycy5qcyc7XG5pbXBvcnQgeyBmcyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB4bWxkb20gZnJvbSAneG1sZG9tJztcbmltcG9ydCB4cGF0aCBmcm9tICd4cGF0aCc7XG5cbmxldCBtYW5pZmVzdE1ldGhvZHMgPSB7fTtcblxuLy8gYW5kcm9pZDpwcm9jZXNzPSBtYXkgYmUgZGVmaW5lZCBpbiBBbmRyb2lkTWFuaWZlc3QueG1sXG4vLyBodHRwOi8vZGV2ZWxvcGVyLmFuZHJvaWQuY29tL3JlZmVyZW5jZS9hbmRyb2lkL1IuYXR0ci5odG1sI3Byb2Nlc3Ncbi8vIG5vdGUgdGhhdCB0aGUgcHJvY2VzcyBuYW1lIHdoZW4gdXNlZCB3aXRoIHBzIG11c3QgYmUgdHJ1bmNhdGVkIHRvIHRoZSBsYXN0IDE1IGNoYXJzXG4vLyBwcyAtYyBjb20uZXhhbXBsZS5hbmRyb2lkLmFwaXMgYmVjb21lcyBwcyAtYyBsZS5hbmRyb2lkLmFwaXNcbm1hbmlmZXN0TWV0aG9kcy5wcm9jZXNzRnJvbU1hbmlmZXN0ID0gYXN5bmMgZnVuY3Rpb24gKGxvY2FsQXBrKSB7XG4gIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgbG9nLmluZm8oXCJSZXRyaWV2aW5nIHByb2Nlc3MgZnJvbSBtYW5pZmVzdFwiKTtcbiAgbGV0IGFyZ3MgPSBbJ2R1bXAnLCAneG1sdHJlZScsIGxvY2FsQXBrLCAnQW5kcm9pZE1hbmlmZXN0LnhtbCddO1xuICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuYWFwdCwgYXJncyk7XG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoXCJcXG5cIik7XG4gIGxldCBhcHBsaWNhdGlvblJlZ2V4ID0gbmV3IFJlZ0V4cCgvXFxzK0U6IGFwcGxpY2F0aW9uIFxcKGxpbmU9XFxkK1xcKS4qLyk7XG4gIGxldCBhcHBsaWNhdGlvbkZvdW5kID0gZmFsc2U7XG4gIGxldCBhdHRyaWJ1dGVSZWdleCA9IG5ldyBSZWdFeHAoL1xccytBOiAuKy8pO1xuICBsZXQgcHJvY2Vzc1JlZ2V4ID0gbmV3IFJlZ0V4cCgvXFxzK0E6IGFuZHJvaWQ6cHJvY2Vzc1xcKDB4MDEwMTAwMTFcXCk9XCIoW15cIl0rKS4qXCIvKTtcbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIGlmICghYXBwbGljYXRpb25Gb3VuZCkge1xuICAgICAgaWYgKGFwcGxpY2F0aW9uUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICBhcHBsaWNhdGlvbkZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5vdEF0dHJpYnV0ZSA9ICFhdHRyaWJ1dGVSZWdleC50ZXN0KGxpbmUpO1xuICAgICAgLy8gcHJvY2VzcyBtdXN0IGJlIGFuIGF0dHJpYnV0ZSBhZnRlciBhcHBsaWNhdGlvbi5cbiAgICAgIGlmIChub3RBdHRyaWJ1dGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgcHJvY2VzcyA9IHByb2Nlc3NSZWdleC5leGVjKGxpbmUpO1xuICAgICAgLy8gdGhpcyBpcyBhbiBhcHBsaWNhdGlvbiBhdHRyaWJ1dGUgcHJvY2Vzcy5cbiAgICAgIGlmIChwcm9jZXNzICYmIHByb2Nlc3MubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBwcm9jZXNzWzFdO1xuICAgICAgICAvLyBtdXN0IHRyaW0gdG8gbGFzdCAxNSBmb3IgYW5kcm9pZCdzIHBzIGJpbmFyeVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDE1KSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cihyZXN1bHQubGVuZ3RoIC0gMTUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBUEtJbmZvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBrUGFja2FnZSAtIFRoZSBuYW1lIG9mIGFwcGxpY2F0aW9uIHBhY2thZ2UsIGZvciBleGFtcGxlICdjb20uYWNtZS5hcHAnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFwa0FjdGl2aXR5IC0gVGhlIG5hbWUgb2YgbWFpbiBhcHBsaWNhdGlvbiBhY3Rpdml0eS5cbiAqL1xuXG4gLyoqXG4gKiBFeHRyYWN0IHBhY2thZ2UgYW5kIG1haW4gYWN0aXZpdHkgbmFtZSBmcm9tIGFwcGxpY2F0aW9uIG1hbmlmZXN0IHVzaW5nXG4gKiB0aGUgY3VzdG9tIGFwayB0b29scy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxBcGsgLSBUaGUgZnVsbCBwYXRoIHRvIGFwcGxpY2F0aW9uIHBhY2thZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWFwdFBhdGggLSBUaGUgZnVsbCBwYXRoIHRvIGFwcHQgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGphclBhdGggLSBUaGUgZnVsbCBwYXRoIHRvIGFwcGl1bV9hcGtfdG9vbHMuamFyIHV0aWxpdHlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0bXBSb290IC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgY2xhc3Mtd2lkZSB0ZW1wb3JhcnkgZm9sZGVyLlxuICogQHJldHVybiB7QVBLSW5mb30gVGhlIHBhcnNlZCBhcHBsaWNhdGlvbiBpbmZvLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGdpdmVuXG4gKiAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gcGFja2FnZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEFwa0luZm9XaXRoQXBrVG9vbHMgKGxvY2FsQXBrLCBhYXB0UGF0aCwgamFyUGF0aCwgdG1wUm9vdCkge1xuICBsb2cuaW5mbyhcIkV4dHJhY3RpbmcgcGFja2FnZSBhbmQgbGF1bmNoIGFjdGl2aXR5IGZyb20gbWFuaWZlc3RcIik7XG4gIGxldCBhcmdzID0gWydkdW1wJywgJ2JhZGdpbmcnLCBsb2NhbEFwa107XG4gIGxldCBzdGRvdXQgPSAoYXdhaXQgZXhlYyhhYXB0UGF0aCwgYXJncykpLnN0ZG91dDtcbiAgbGV0IGFwa1BhY2thZ2UgPSBuZXcgUmVnRXhwKC9wYWNrYWdlOiBuYW1lPScoW14nXSspJy9nKS5leGVjKHN0ZG91dCk7XG4gIGlmICghYXBrUGFja2FnZSB8fCBhcGtQYWNrYWdlLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBwYWNrYWdlIG5hbWUgZnJvbSBgICtcbiAgICAgIGAnJHtfLmpvaW4oW2FhcHRQYXRoLCAnZHVtcCcsICdiYWRnaW5nJywgJ1wiJyArIGxvY2FsQXBrICsgJ1wiJ10sICcgJyl9JyBjb21tYW5kICBvdXRwdXRgKTtcbiAgfVxuICBhcGtQYWNrYWdlID0gYXBrUGFja2FnZVsxXTtcbiAgbGV0IGFwa0FjdGl2aXR5ID0gbmV3IFJlZ0V4cCgvbGF1bmNoYWJsZS1hY3Rpdml0eTogbmFtZT0nKFteJ10rKScvZykuZXhlYyhzdGRvdXQpO1xuICBpZiAoYXBrQWN0aXZpdHkgJiYgYXBrQWN0aXZpdHkubGVuZ3RoID49IDIpIHtcbiAgICBhcGtBY3Rpdml0eSA9IGFwa0FjdGl2aXR5WzFdO1xuICAgIHJldHVybiB7YXBrUGFja2FnZSwgYXBrQWN0aXZpdHl9O1xuICB9XG5cbiAgbGV0IG91dHB1dFBhdGggPSBwYXRoLnJlc29sdmUodG1wUm9vdCwgYXBrUGFja2FnZSk7XG4gIGxldCBnZXRMYXVuY2hBY3Rpdml0eSA9IFtcbiAgICAnLWphcicsIGphclBhdGgsXG4gICAgJ3ByaW50TGF1bmNoQWN0aXZpdHknLCBsb2NhbEFwayxcbiAgICBvdXRwdXRQYXRoXG4gIF07XG4gIGNvbnN0IG91dHB1dCA9IGF3YWl0IGV4ZWMoJ2phdmEnLCBnZXRMYXVuY2hBY3Rpdml0eSk7XG4gIGlmIChvdXRwdXQuc3RkZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgbGF1bmNoQWN0aXZpdHkgZnJvbSBtYW5pZmVzdDogJHtvdXRwdXQuc3RkZXJyfWApO1xuICB9XG4gIHN0ZG91dCA9IG91dHB1dC5zdGRvdXQ7XG4gIGxldCBhY3QgPSBuZXcgUmVnRXhwKC9MYXVuY2ggYWN0aXZpdHkgcGFyc2VkOihbXiddKykvZykuZXhlYyhzdGRvdXQpO1xuICBpZiAoYWN0ICYmIGFjdC5sZW5ndGggPj0gMikge1xuICAgIGFwa0FjdGl2aXR5ID0gYWN0WzFdO1xuICAgIHJldHVybiB7YXBrUGFja2FnZSwgYXBrQWN0aXZpdHl9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIG1haW4gYWN0aXZpdHkgbmFtZSBmcm9tICcke3N0ZG91dH0nIGNvbW1hbmQgIG91dHB1dGApO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgcGFja2FnZSBhbmQgbWFpbiBhY3Rpdml0eSBuYW1lIGZyb20gYXBwbGljYXRpb24gbWFuaWZlc3QgdXNpbmdcbiAqIGFwa2FuYWx5emVyIHRvb2wuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsQXBrIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGFwa2FuYWx5emVyUGF0aCAtIFRoZSBmdWxsIHBhdGggdG8gYXBrYW5hbHl6ZXIgdG9vbC5cbiAqIEByZXR1cm4ge0FQS0luZm99IFRoZSBwYXJzZWQgYXBwbGljYXRpb24gaW5mby5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBnaXZlblxuICogICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIHBhY2thZ2Ugb3IgaWYgdGhlIHRvb2wgaXRzZWxmXG4gKiAgICAgICAgICAgICAgICAgaXMgbm90IHByZXNlbnQgb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtLlxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0QXBrSW5mb1dpdGhBcGthbmFseXplciAobG9jYWxBcGssIGFwa2FuYWx5emVyUGF0aCkge1xuICBjb25zdCBhcmdzID0gWyctaCcsICdtYW5pZmVzdCcsICdwcmludCcsIGxvY2FsQXBrXTtcbiAgbG9nLmRlYnVnKGBTdGFydGluZyAnJHthcGthbmFseXplclBhdGh9JyB3aXRoIGFyZ3MgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgY29uc3QgbWFuaWZlc3RYbWwgPSAoYXdhaXQgZXhlYyhhcGthbmFseXplclBhdGgsIGFyZ3MsIHtcbiAgICBzaGVsbDogdHJ1ZSxcbiAgICBjd2Q6IHBhdGguZGlybmFtZShhcGthbmFseXplclBhdGgpXG4gIH0pKS5zdGRvdXQ7XG4gIGNvbnN0IGRvYyA9IG5ldyB4bWxkb20uRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKG1hbmlmZXN0WG1sKTtcbiAgY29uc3QgYXBrUGFja2FnZUF0dHJpYnV0ZSA9IHhwYXRoLnNlbGVjdDEoJy8vbWFuaWZlc3QvQHBhY2thZ2UnLCBkb2MpO1xuICBpZiAoIWFwa1BhY2thZ2VBdHRyaWJ1dGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBwYWNrYWdlIG5hbWUgZnJvbSAke21hbmlmZXN0WG1sfWApO1xuICB9XG4gIGNvbnN0IGFwa1BhY2thZ2UgPSBhcGtQYWNrYWdlQXR0cmlidXRlLnZhbHVlO1xuICAvLyBMb29rIGZvciBhY3Rpdml0eSBvciBhY3Rpdml0eS1hbGlhcyB3aXRoXG4gIC8vIGFjdGlvbiA9PSBhbmRyb2lkLmludGVudC5hY3Rpb24uTUFJTiBhbmRcbiAgLy8gY2F0ZWdvcnkgPT0gYW5kcm9pZC5pbnRlbnQuY2F0ZWdvcnkuTEFVTkNIRVJcbiAgLy8gZGVzY2VuZGFudHNcbiAgY29uc3QgYXBrQWN0aXZpdHlBdHRyaWJ1dGUgPSB4cGF0aC5zZWxlY3QxKFxuICAgIFwiLy9hcHBsaWNhdGlvbi8qW3N0YXJ0cy13aXRoKG5hbWUoKSwgJ2FjdGl2aXR5JykgXCIgK1xuICAgIFwiYW5kIC4vL2FjdGlvbltAKltsb2NhbC1uYW1lKCk9J25hbWUnIGFuZCAuPSdhbmRyb2lkLmludGVudC5hY3Rpb24uTUFJTiddXSBcIiArXG4gICAgXCJhbmQgLi8vY2F0ZWdvcnlbQCpbbG9jYWwtbmFtZSgpPSduYW1lJyBhbmQgLj0nYW5kcm9pZC5pbnRlbnQuY2F0ZWdvcnkuTEFVTkNIRVInXV1dXCIgK1xuICAgIFwiL0AqW2xvY2FsLW5hbWUoKT0nbmFtZSddXCIsIGRvYyk7XG4gIGlmICghYXBrQWN0aXZpdHlBdHRyaWJ1dGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBtYWluIGFjdGl2aXR5IG5hbWUgZnJvbSAke21hbmlmZXN0WG1sfWApO1xuICB9XG4gIGNvbnN0IGFwa0FjdGl2aXR5ID0gYXBrQWN0aXZpdHlBdHRyaWJ1dGUudmFsdWU7XG4gIHJldHVybiB7YXBrUGFja2FnZSwgYXBrQWN0aXZpdHl9O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgcGFja2FnZSBhbmQgbWFpbiBhY3Rpdml0eSBuYW1lIGZyb20gYXBwbGljYXRpb24gbWFuaWZlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsQXBrIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICogQHJldHVybiB7QVBLSW5mb30gVGhlIHBhcnNlZCBhcHBsaWNhdGlvbiBpbmZvLlxuICogQHRocm93cyB7ZXJyb3J9IElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGdpdmVuXG4gKiAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gcGFja2FnZS5cbiAqL1xubWFuaWZlc3RNZXRob2RzLnBhY2thZ2VBbmRMYXVuY2hBY3Rpdml0eUZyb21NYW5pZmVzdCA9IGFzeW5jIGZ1bmN0aW9uIChsb2NhbEFwaykge1xuICBjb25zdCBhcGtJbmZvR2V0dGVycyA9IFtcbiAgICBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhcGthbmFseXplclBhdGggPSBhd2FpdCBnZXRBcGthbmFseXplckZvck9zKHRoaXMpO1xuICAgICAgcmV0dXJuIGF3YWl0IGV4dHJhY3RBcGtJbmZvV2l0aEFwa2FuYWx5emVyKGxvY2FsQXBrLCBhcGthbmFseXplclBhdGgpO1xuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5pbml0QWFwdCgpO1xuICAgICAgcmV0dXJuIGF3YWl0IGV4dHJhY3RBcGtJbmZvV2l0aEFwa1Rvb2xzKGxvY2FsQXBrLFxuICAgICAgICB0aGlzLmJpbmFyaWVzLmFhcHQsIHRoaXMuamFyc1snYXBwaXVtX2Fwa190b29scy5qYXInXSwgdGhpcy50bXBEaXIpO1xuICAgIH0sXG4gIF07XG5cbiAgbGV0IHNhdmVkRXJyb3I7XG4gIGZvciAoY29uc3QgaW5mb0dldHRlciBvZiBhcGtJbmZvR2V0dGVycykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7YXBrUGFja2FnZSwgYXBrQWN0aXZpdHl9ID0gYXdhaXQgaW5mb0dldHRlcigpO1xuICAgICAgbG9nLmluZm8oYFBhY2thZ2UgbmFtZTogJyR7YXBrUGFja2FnZX0nYCk7XG4gICAgICBsb2cuaW5mbyhgTWFpbiBhY3Rpdml0eSBuYW1lOiAnJHthcGtBY3Rpdml0eX0nYCk7XG4gICAgICByZXR1cm4ge2Fwa1BhY2thZ2UsIGFwa0FjdGl2aXR5fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaW5mb0dldHRlciAhPT0gXy5sYXN0KGFwa0luZm9HZXR0ZXJzKSkge1xuICAgICAgICBsb2cuaW5mbyhgVXNpbmcgdGhlIGFsdGVybmF0aXZlIGFjdGl2aXR5IG5hbWUgZGV0ZWN0aW9uIG1ldGhvZCBgK1xuICAgICAgICAgICAgICAgICBgYmVjYXVzZSBvZjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBzYXZlZEVycm9yID0gZTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBwYWNrYWdlQW5kTGF1bmNoQWN0aXZpdHlGcm9tTWFuaWZlc3QgZmFpbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtzYXZlZEVycm9yLm1lc3NhZ2V9YCArXG4gICAgICAgICAgICAgICAgICAoc2F2ZWRFcnJvci5zdGRlcnIgPyBgOyBTdGRFcnI6ICR7c2F2ZWRFcnJvci5zdGRlcnJ9YCA6ICcnKSk7XG59O1xuXG4vKipcbiAqIEV4dHJhY3QgdGFyZ2V0IFNESyB2ZXJzaW9uIGZyb20gYXBwbGljYXRpb24gbWFuaWZlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsQXBrIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVyc2lvbiBvZiB0aGUgdGFyZ2V0IFNESy5cbiAqIEB0aHJvd3Mge2Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZ2V0dGluZyB0aGUgZGF0YSBmcm9tIHRoZSBnaXZlblxuICogICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIHBhY2thZ2UuXG4gKi9cbm1hbmlmZXN0TWV0aG9kcy50YXJnZXRTZGtWZXJzaW9uRnJvbU1hbmlmZXN0ID0gYXN5bmMgZnVuY3Rpb24gKGxvY2FsQXBrKSB7XG4gIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgbG9nLmluZm8oXCJFeHRyYWN0aW5nIHBhY2thZ2UgYW5kIGxhdW5jaCBhY3Rpdml0eSBmcm9tIG1hbmlmZXN0XCIpO1xuICBsZXQgYXJncyA9IFsnZHVtcCcsICdiYWRnaW5nJywgbG9jYWxBcGtdO1xuICBsZXQgb3V0cHV0O1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy5hYXB0LCBhcmdzKTtcbiAgICBvdXRwdXQgPSBzdGRvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZldGNoaW5nIHRhcmdldFNka1ZlcnNpb24gZnJvbSBsb2NhbCBBUEsgZmFpbGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbiAgbGV0IHRhcmdldFNka1ZlcnNpb24gPSBuZXcgUmVnRXhwKC90YXJnZXRTZGtWZXJzaW9uOicoW14nXSspJy9nKS5leGVjKG91dHB1dCk7XG4gIGlmICghdGFyZ2V0U2RrVmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgdGFyZ2V0U2RrVmVyc2lvbiBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhcHBsaWNhdGlvbi5gKTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodGFyZ2V0U2RrVmVyc2lvblsxXSwgMTApO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0IHRhcmdldCBTREsgdmVyc2lvbiBmcm9tIHBhY2thZ2UgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBwYWNrYWdlIGluc3RhbGxlZCBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2ZXJzaW9uIG9mIHRoZSB0YXJnZXQgU0RLLlxuICovXG5tYW5pZmVzdE1ldGhvZHMudGFyZ2V0U2RrVmVyc2lvblVzaW5nUEtHID0gYXN5bmMgZnVuY3Rpb24gKHBrZykge1xuICBsZXQgc3Rkb3V0ID0gIGF3YWl0IHRoaXMuc2hlbGwoWydkdW1wc3lzJywgJ3BhY2thZ2UnLCBwa2ddKTtcbiAgbGV0IHRhcmdldFNka1ZlcnNpb24gPSBuZXcgUmVnRXhwKC90YXJnZXRTZGs9KFteXFxzXFxzXSspL2cpLmV4ZWMoc3Rkb3V0KTtcbiAgaWYgKHRhcmdldFNka1ZlcnNpb24gJiYgdGFyZ2V0U2RrVmVyc2lvbi5sZW5ndGggPj0gMikge1xuICAgIHRhcmdldFNka1ZlcnNpb24gPSB0YXJnZXRTZGtWZXJzaW9uWzFdO1xuICB9IGVsc2Uge1xuICAgIC8vIHRhcmdldFNkayBub3QgZm91bmQgaW4gdGhlIGR1bXAsIGFzc2lnbmluZyAwIHRvIHRhcmdldFNka1ZlcnNpb25cbiAgICB0YXJnZXRTZGtWZXJzaW9uID0gMDtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQodGFyZ2V0U2RrVmVyc2lvbiwgMTApO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHBhY2thZ2UgbWFuaWZlc3QgKHVzdWFsbHkgQW5kcm9pZE1hbmlmZXN0LnhtbCkuXG4gKiBgJHttYW5pZmVzdH0uYXBrYCBmaWxlIHdpbGwgYmUgY3JlYXRlZCBhcyB0aGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kXG4gKiBjb250YWluaW5nIHRoZSBjb21waWxlZCBtYW5pZmVzdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3QgLSBGdWxsIHBhdGggdG8gdGhlIGluaXRpYWwgbWFuaWZlc3QgdGVtcGxhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYW5pZmVzdFBhY2thZ2UgLSBUaGUgbmFtZSBvZiB0aGUgbWFuaWZlc3QgcGFja2FnZVxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFBhY2thZ2UgLSBUaGUgbmFtZSBvZiB0aGUgZGVzdGluYXRpb24gcGFja2FnZVxuICovXG5tYW5pZmVzdE1ldGhvZHMuY29tcGlsZU1hbmlmZXN0ID0gYXN5bmMgZnVuY3Rpb24gKG1hbmlmZXN0LCBtYW5pZmVzdFBhY2thZ2UsIHRhcmdldFBhY2thZ2UpIHtcbiAgbG9nLmRlYnVnKGBDb21waWxpbmcgbWFuaWZlc3QgJHttYW5pZmVzdH1gKTtcbiAgbGV0IHtwbGF0Zm9ybSwgcGxhdGZvcm1QYXRofSA9IGF3YWl0IGdldEFuZHJvaWRQbGF0Zm9ybUFuZFBhdGgoKTtcbiAgaWYgKCFwbGF0Zm9ybSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVpcmVkIHBsYXRmb3JtIGRvZXNuJ3QgZXhpc3QgKEFQSSBsZXZlbCA+PSAxNylcIik7XG4gIH1cbiAgbG9nLmRlYnVnKCdDb21waWxpbmcgbWFuaWZlc3QuJyk7XG4gIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuYWFwdCwgW1xuICAgICAgJ3BhY2thZ2UnLFxuICAgICAgJy1NJywgbWFuaWZlc3QsXG4gICAgICAnLS1yZW5hbWUtbWFuaWZlc3QtcGFja2FnZScsIG1hbmlmZXN0UGFja2FnZSxcbiAgICAgICctLXJlbmFtZS1pbnN0cnVtZW50YXRpb24tdGFyZ2V0LXBhY2thZ2UnLCB0YXJnZXRQYWNrYWdlLFxuICAgICAgJy1JJywgcGF0aC5yZXNvbHZlKHBsYXRmb3JtUGF0aCwgJ2FuZHJvaWQuamFyJyksXG4gICAgICAnLUYnLCBgJHttYW5pZmVzdH0uYXBrYCxcbiAgICAgICctZicsXG4gICAgXSk7XG4gICAgbG9nLmRlYnVnKFwiQ29tcGlsZWQgbWFuaWZlc3RcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY29tcGlsaW5nIG1hbmlmZXN0LiBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXBsYWNlL2luc2VydCB0aGUgc3BlY2lhbGx5IHByZWNvbXBpbGVkIG1hbmlmZXN0IGZpbGUgaW50byB0aGVcbiAqIHBhcnRpY3VsYXIgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFuaWZlc3QgLSBGdWxsIHBhdGggdG8gdGhlIHByZWNvbXBpbGVkIG1hbmlmZXN0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkIGJ5IGBjb21waWxlTWFuaWZlc3RgIG1ldGhvZCBjYWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IC5hcGsgZXh0ZW5zaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjQXBrIC0gRnVsbCBwYXRoIHRvIHRoZSBleGlzdGluZyB2YWxpZCBhcHBsaWNhdGlvbiBwYWNrYWdlLCB3aGVyZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgbWFuaWZlc3QgaGFzIHRvIGJlIGluc2V0cmVkIHRvLiBUaGlzIHBhY2thZ2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIE5PVCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkc3RBcGsgLSBGdWxsIHBhdGggdG8gdGhlIHJlc3VsdGluZyBwYWNrYWdlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaWxlIHdpbGwgYmUgb3ZlcnJpZGVuIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICovXG5tYW5pZmVzdE1ldGhvZHMuaW5zZXJ0TWFuaWZlc3QgPSBhc3luYyBmdW5jdGlvbiAobWFuaWZlc3QsIHNyY0FwaywgZHN0QXBrKSB7XG4gIGxvZy5kZWJ1ZyhgSW5zZXJ0aW5nIG1hbmlmZXN0LCBzcmM6ICR7c3JjQXBrfSBkc3Q6ICR7ZHN0QXBrfWApO1xuICBhd2FpdCB0aGlzLmluaXRBYXB0KCk7XG4gIGF3YWl0IHVuemlwRmlsZShgJHttYW5pZmVzdH0uYXBrYCk7XG4gIGF3YWl0IGZzLmNvcHlGaWxlKHNyY0FwaywgZHN0QXBrKTtcbiAgbG9nLmRlYnVnKFwiVGVzdGluZyBuZXcgdG1wIGFwa1wiKTtcbiAgYXdhaXQgYXNzZXJ0WmlwQXJjaGl2ZShkc3RBcGspO1xuICBsb2cuZGVidWcoXCJNb3ZpbmcgbWFuaWZlc3RcIik7XG4gIHRyeSB7XG4gICAgYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQsIFtcbiAgICAgICdyZW1vdmUnLCBkc3RBcGssIHBhdGguYmFzZW5hbWUobWFuaWZlc3QpXG4gICAgXSk7XG4gIH0gY2F0Y2ggKGlnbikge31cbiAgYXdhaXQgZXhlYyh0aGlzLmJpbmFyaWVzLmFhcHQsIFtcbiAgICAnYWRkJywgZHN0QXBrLCBwYXRoLmJhc2VuYW1lKG1hbmlmZXN0KVxuICBdLCB7Y3dkOiBwYXRoLmRpcm5hbWUobWFuaWZlc3QpfSk7XG4gIGxvZy5kZWJ1ZyhcIkluc2VydGVkIG1hbmlmZXN0LlwiKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBwYWNrYWdlIG1hbmlmZXN0IGNvbnRhaW5zIEludGVybmV0IHBlcm1pc3Npb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbEFwayAtIFRoZSBmdWxsIHBhdGggdG8gYXBwbGljYXRpb24gcGFja2FnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1hbmlmZXN0IHJlcXVpcmVzIEludGVybmV0IGFjY2VzcyBwZXJtaXNzaW9uLlxuICovXG5tYW5pZmVzdE1ldGhvZHMuaGFzSW50ZXJuZXRQZXJtaXNzaW9uRnJvbU1hbmlmZXN0ID0gYXN5bmMgZnVuY3Rpb24gKGxvY2FsQXBrKSB7XG4gIGF3YWl0IHRoaXMuaW5pdEFhcHQoKTtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBpZiAnJHtsb2NhbEFwa30nIHJlcXVpcmVzIGludGVybmV0IGFjY2VzcyBwZXJtaXNzaW9uIGluIHRoZSBtYW5pZmVzdGApO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy5hYXB0LCBbJ2R1bXAnLCAnYmFkZ2luZycsIGxvY2FsQXBrXSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoL3VzZXMtcGVybWlzc2lvbjouKidhbmRyb2lkLnBlcm1pc3Npb24uSU5URVJORVQnLykudGVzdChzdGRvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2hlY2sgaWYgJyR7bG9jYWxBcGt9JyByZXF1aXJlcyBpbnRlcm5ldCBhY2Nlc3MgcGVybWlzc2lvbi4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qXG4gKiBQcmludHMgb3V0IHRoZSBtYW5pZmVzdCBleHRyYWN0ZWQgZnJvbSB0aGUgYXBrXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsQXBrIC0gVGhlIGZ1bGwgcGF0aCB0byBhcHBsaWNhdGlvbiBwYWNrYWdlLlxuICogQHBhcmFtIHs/c3RyaW5nfSBsb2dMZXZlbCAtIFRoZSBsZXZlbCBhdCB3aGljaCB0byBsb2cuIEUuZy4sICdkZWJ1ZydcbiAqL1xubWFuaWZlc3RNZXRob2RzLnByaW50TWFuaWZlc3RGcm9tQXBrID0gYXN5bmMgZnVuY3Rpb24gcHJpbnRNYW5pZmVzdEZyb21BcGsgKGxvY2FsQXBrLCBsb2dMZXZlbCA9ICdkZWJ1ZycpIHtcbiAgYXdhaXQgdGhpcy5pbml0QWFwdCgpO1xuICBsb2dbbG9nTGV2ZWxdKGBBbmRyb2lkIG1hbmlmZXN0IGV4dHJhY3RlZCBmcm9tICcke2xvY2FsQXBrfSdgKTtcbiAgbGV0IG91dCA9IGZhbHNlO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5iaW5hcmllcy5hYXB0LCBbJ2wnLCAnLWEnLCBsb2NhbEFwa10pO1xuICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3Rkb3V0LnNwbGl0KCdcXG4nKSkge1xuICAgIGlmICghb3V0ICYmIGxpbmUuaW5jbHVkZXMoJ0FuZHJvaWQgbWFuaWZlc3Q6JykpIHtcbiAgICAgIG91dCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvdXQpIHtcbiAgICAgIGxvZ1tsb2dMZXZlbF0obGluZSk7XG4gICAgfVxuICB9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IG1hbmlmZXN0TWV0aG9kcztcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
