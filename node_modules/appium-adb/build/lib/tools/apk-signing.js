'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _teen_process = require('teen_process');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _appiumSupport = require('appium-support');

var _helpersJs = require('../helpers.js');

var DEFAULT_PRIVATE_KEY = _path2['default'].resolve(_helpersJs.rootDir, 'keys', 'testkey.pk8');
var DEFAULT_CERTIFICATE = _path2['default'].resolve(_helpersJs.rootDir, 'keys', 'testkey.x509.pem');
var DEFAULT_CERT_DIGEST = 'a40da80a59d170caa950cf15c18c454d47a39b26989d8b640ecd745ba71bf5dc';

var apkSigningMethods = {};

/**
 * Applies the patch, which workarounds'-Djava.ext.dirs is not supported. Use -classpath instead.'
 * error on Windows by creating a temporary patched copy of the original apksigner script.
 *
 * @param {string} originalPath - The original path to apksigner tool
 * @returns {string} The full path to the patched script or the same path if there is
 *                   no need to patch the original file.
 */
function patchApksigner(originalPath) {
  var originalContent, patchedContent, patchedPath;
  return _regeneratorRuntime.async(function patchApksigner$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readFile(originalPath, 'ascii'));

      case 2:
        originalContent = context$1$0.sent;
        patchedContent = originalContent.replace('-Djava.ext.dirs="%frameworkdir%"', '-cp "%frameworkdir%\\*"');

        if (!(patchedContent === originalContent)) {
          context$1$0.next = 6;
          break;
        }

        return context$1$0.abrupt('return', originalPath);

      case 6:
        _loggerJs2['default'].debug('Patching \'' + originalPath + '...');
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'apksigner', suffix: '.bat' }));

      case 9:
        patchedPath = context$1$0.sent;
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(_path2['default'].dirname(patchedPath)));

      case 12:
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(patchedPath, patchedContent, 'ascii'));

      case 14:
        return context$1$0.abrupt('return', patchedPath);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

/**
 * Execute apksigner utility with given arguments.
 *
 * @param {?Array<String>} args - The list of tool arguments.
 * @return {string} - Command stdout
 * @throws {Error} If apksigner binary is not present on the local file system
 *                 or the return code is not equal to zero.
 */
apkSigningMethods.executeApksigner = function callee$0$0() {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  var apkSigner, originalFolder, getApksignerOutput, _arr2, _i2, _arr2$_i2, _name2, stream, patchedApksigner;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _helpersJs.getApksignerForOs)(this));

      case 2:
        apkSigner = context$1$0.sent;
        originalFolder = _path2['default'].dirname(apkSigner);

        getApksignerOutput = function getApksignerOutput(apksignerPath) {
          var _ref, stdout, stderr, _arr, _i, _arr$_i, _name, stream;

          return _regeneratorRuntime.async(function getApksignerOutput$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(apksignerPath, args, {
                  cwd: originalFolder
                }));

              case 2:
                _ref = context$2$0.sent;
                stdout = _ref.stdout;
                stderr = _ref.stderr;
                _arr = [['stdout', stdout], ['stderr', stderr]];

                for (_i = 0; _i < _arr.length; _i++) {
                  _arr$_i = _slicedToArray(_arr[_i], 2);
                  _name = _arr$_i[0];
                  stream = _arr$_i[1];

                  if (stream) {
                    _loggerJs2['default'].debug('apksigner ' + _name + ': ' + stream);
                  }
                }
                return context$2$0.abrupt('return', stdout);

              case 8:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        };

        _loggerJs2['default'].debug('Starting \'' + apkSigner + '\' with args \'' + JSON.stringify(args) + '\'');
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(getApksignerOutput(apkSigner));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Got an error during apksigner execution: ' + context$1$0.t0.message);
        _arr2 = [['stdout', context$1$0.t0.stdout], ['stderr', context$1$0.t0.stderr]];
        for (_i2 = 0; _i2 < _arr2.length; _i2++) {
          _arr2$_i2 = _slicedToArray(_arr2[_i2], 2);
          _name2 = _arr2$_i2[0];
          stream = _arr2$_i2[1];

          if (stream) {
            _loggerJs2['default'].warn('apksigner ' + _name2 + ': ' + stream);
          }
        }

        if (!_appiumSupport.system.isWindows()) {
          context$1$0.next = 30;
          break;
        }

        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(patchApksigner(apkSigner));

      case 20:
        patchedApksigner = context$1$0.sent;

        if (!(patchedApksigner !== apkSigner)) {
          context$1$0.next = 30;
          break;
        }

        context$1$0.prev = 22;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(getApksignerOutput(patchedApksigner));

      case 25:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 26:
        context$1$0.prev = 26;
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(patchedApksigner));

      case 29:
        return context$1$0.finish(26);

      case 30:
        throw context$1$0.t0;

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 12], [22,, 26, 30]]);
};

/**
 * (Re)sign the given apk file on the local file system with the default certificate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If signing fails.
 */
apkSigningMethods.signWithDefaultCert = function callee$0$0(apk) {
  var args, java, signPath;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Signing \'' + apk + '\' with default cert');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apk));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        throw new Error(apk + ' file doesn\'t exist.');

      case 5:
        context$1$0.prev = 5;
        args = ['sign', '--key', DEFAULT_PRIVATE_KEY, '--cert', DEFAULT_CERTIFICATE, apk];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.executeApksigner(args));

      case 9:
        context$1$0.next = 25;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](5);

        _loggerJs2['default'].warn('Cannot use apksigner tool for signing. Defaulting to sign.jar. ' + ('Original error: ' + context$1$0.t0.message) + (context$1$0.t0.stderr ? '; StdErr: ' + context$1$0.t0.stderr : ''));
        java = (0, _helpersJs.getJavaForOs)();
        signPath = _path2['default'].resolve(this.helperJarPath, 'sign.jar');

        _loggerJs2['default'].debug("Resigning apk.");
        context$1$0.prev = 17;
        context$1$0.next = 20;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(java, ['-jar', signPath, apk, '--override']));

      case 20:
        context$1$0.next = 25;
        break;

      case 22:
        context$1$0.prev = 22;
        context$1$0.t1 = context$1$0['catch'](17);
        throw new Error('Could not sign with default certificate. Original error ' + context$1$0.t1.message);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[5, 11], [17, 22]]);
};

/**
 * (Re)sign the given apk file on the local file system with a custom certificate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If signing fails.
 */
apkSigningMethods.signWithCustomCert = function callee$0$0(apk) {
  var args, jarsigner;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Signing \'' + apk + '\' with custom cert');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(this.keystorePath));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 5;
          break;
        }

        throw new Error('Keystore: ' + this.keystorePath + ' doesn\'t exist.');

      case 5:
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apk));

      case 7:
        if (context$1$0.sent) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('\'' + apk + '\' doesn\'t exist.');

      case 9:
        context$1$0.prev = 9;
        args = ['sign', '--ks', this.keystorePath, '--ks-key-alias', this.keyAlias, '--ks-pass', 'pass:' + this.keystorePassword, '--key-pass', 'pass:' + this.keyPassword, apk];
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.executeApksigner(args));

      case 13:
        context$1$0.next = 31;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](9);

        _loggerJs2['default'].warn('Cannot use apksigner tool for signing. Defaulting to jarsigner. ' + ('Original error: ' + context$1$0.t0.message));
        context$1$0.prev = 18;

        _loggerJs2['default'].debug("Unsigning apk.");
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)((0, _helpersJs.getJavaForOs)(), ['-jar', _path2['default'].resolve(this.helperJarPath, 'unsign.jar'), apk]));

      case 22:
        _loggerJs2['default'].debug("Signing apk.");
        jarsigner = _path2['default'].resolve((0, _helpersJs.getJavaHome)(), 'bin', 'jarsigner' + (_appiumSupport.system.isWindows() ? '.exe' : ''));
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(jarsigner, ['-sigalg', 'MD5withRSA', '-digestalg', 'SHA1', '-keystore', this.keystorePath, '-storepass', this.keystorePassword, '-keypass', this.keyPassword, apk, this.keyAlias]));

      case 26:
        context$1$0.next = 31;
        break;

      case 28:
        context$1$0.prev = 28;
        context$1$0.t1 = context$1$0['catch'](18);
        throw new Error('Could not sign with custom certificate. Original error ' + context$1$0.t1.message);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[9, 15], [18, 28]]);
};

/**
 * (Re)sign the given apk file on the local file system with either
 * custom or default certificate based on _this.useKeystore_ property value
 * and Zip-aligns it after signing.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If signing fails.
 */
apkSigningMethods.sign = function callee$0$0(apk) {
  var apksignerFound;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        apksignerFound = true;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _helpersJs.getApksignerForOs)(this));

      case 4:
        context$1$0.next = 9;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        apksignerFound = false;

      case 9:
        if (!apksignerFound) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.prev = 10;
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.zipAlignApk(apk));

      case 13:
        context$1$0.next = 17;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t1 = context$1$0['catch'](10);

      case 17:
        if (!this.useKeystore) {
          context$1$0.next = 22;
          break;
        }

        context$1$0.next = 20;
        return _regeneratorRuntime.awrap(this.signWithCustomCert(apk));

      case 20:
        context$1$0.next = 24;
        break;

      case 22:
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(this.signWithDefaultCert(apk));

      case 24:
        if (apksignerFound) {
          context$1$0.next = 27;
          break;
        }

        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(this.zipAlignApk(apk));

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 6], [10, 15]]);
};

/**
 * Perform zip-aligning to the given local apk file.
 *
 * @param {string} apk - The full path to the local apk file.
 * @throws {Error} If zip-align fails.
 */
apkSigningMethods.zipAlignApk = function callee$0$0(apk) {
  var alignedApk;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Zip-aligning \'' + apk + '\'');
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.initZipAlign());

      case 3:
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.path({ prefix: 'appium', suffix: '.tmp' }));

      case 5:
        alignedApk = context$1$0.sent;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(_path2['default'].dirname(alignedApk)));

      case 8:
        context$1$0.prev = 8;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.binaries.zipalign, ['-f', '4', apk, alignedApk]));

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.mv(alignedApk, apk, { mkdirp: true }));

      case 13:
        context$1$0.next = 23;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](8);
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(alignedApk));

      case 19:
        if (!context$1$0.sent) {
          context$1$0.next = 22;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.unlink(alignedApk));

      case 22:
        throw new Error('zipAlignApk failed. Original error: ' + context$1$0.t0.message + '. Stdout: \'' + context$1$0.t0.stdout + '\'; Stderr: \'' + context$1$0.t0.stderr + '\'');

      case 23:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[8, 15]]);
};

/**
 * Check if the app is already signed with the default Appium ceritficate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @param {string} pgk - The name of application package.
 * @return {boolean} True if given application is already signed.
 */
apkSigningMethods.checkApkCert = function callee$0$0(apk, pkg) {
  var verificationFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Checking app cert for ' + apk);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(apk));

      case 3:
        if (context$1$0.sent) {
          context$1$0.next = 6;
          break;
        }

        _loggerJs2['default'].debug('\'' + apk + '\' doesn\'t exist');
        return context$1$0.abrupt('return', false);

      case 6:
        if (!this.useKeystore) {
          context$1$0.next = 10;
          break;
        }

        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(this.checkCustomApkCert(apk, pkg));

      case 9:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 10:
        verificationFunc = undefined;
        context$1$0.prev = 11;
        context$1$0.next = 14;
        return _regeneratorRuntime.awrap((0, _helpersJs.getApksignerForOs)(this));

      case 14:
        verificationFunc = function callee$1$0() {
          var output;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.executeApksigner(['verify', '--print-certs', apk]));

              case 2:
                output = context$2$0.sent;

                if (_lodash2['default'].includes(output, DEFAULT_CERT_DIGEST)) {
                  context$2$0.next = 5;
                  break;
                }

                throw new Error('\'' + apk + '\' is signed with non-default certificate');

              case 5:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2);
        };
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](11);

        (function () {
          _loggerJs2['default'].warn('Cannot use apksigner tool for signature verification. Defaulting to verify.jar. ' + ('Original error: ' + context$1$0.t0.message));
          var java = (0, _helpersJs.getJavaForOs)();
          verificationFunc = function callee$3$0() {
            return _regeneratorRuntime.async(function callee$3$0$(context$4$0) {
              while (1) switch (context$4$0.prev = context$4$0.next) {
                case 0:
                  context$4$0.next = 2;
                  return _regeneratorRuntime.awrap((0, _teen_process.exec)(java, ['-jar', _path2['default'].resolve(this.helperJarPath, 'verify.jar'), apk]));

                case 2:
                  return context$4$0.abrupt('return', context$4$0.sent);

                case 3:
                case 'end':
                  return context$4$0.stop();
              }
            }, null, _this2);
          };
        })();

      case 20:
        context$1$0.prev = 20;
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(verificationFunc());

      case 23:
        _loggerJs2['default'].debug('\'' + apk + '\' is already signed.');
        return context$1$0.abrupt('return', true);

      case 27:
        context$1$0.prev = 27;
        context$1$0.t1 = context$1$0['catch'](20);

        _loggerJs2['default'].debug('\'' + apk + '\' is not signed with debug cert.');
        return context$1$0.abrupt('return', false);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[11, 17], [20, 27]]);
};

/**
 * Check if the app is already signed with a custom certificate.
 *
 * @param {string} apk - The full path to the local apk file.
 * @param {string} pgk - The name of application package.
 * @return {boolean} True if given application is already signed with a custom certificate.
 */
apkSigningMethods.checkCustomApkCert = function callee$0$0(apk, pkg) {
  var h, md5Str, md5, javaHome, keytool, keystoreHash;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Checking custom app cert for ' + apk);
        h = "a-fA-F0-9";
        md5Str = ['.*MD5.*((?:[' + h + ']{2}:){15}[' + h + ']{2})'];
        md5 = new RegExp(md5Str, 'mi');
        javaHome = (0, _helpersJs.getJavaHome)();
        keytool = _path2['default'].resolve(javaHome, 'bin', 'keytool' + (_appiumSupport.system.isWindows() ? '.exe' : ''));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getKeystoreMd5(keytool, md5));

      case 8:
        keystoreHash = context$1$0.sent;
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(this.checkApkKeystoreMatch(keytool, md5, keystoreHash, pkg, apk));

      case 11:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the MD5 hash of the keystore.
 *
 * @param {string} keytool - The name of the keytool utility.
 * @param {RegExp} md5re - The pattern used to match the result in _keytool_ output.
 * @return {?string} Keystore MD5 hash or _null_ if the hash cannot be parsed.
 * @throws {Error} If getting keystore MD5 hash fails.
 */
apkSigningMethods.getKeystoreMd5 = function callee$0$0(keytool, md5re) {
  var _ref2, stdout, keystoreHash;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Printing keystore md5.");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(keytool, ['-v', '-list', '-alias', this.keyAlias, '-keystore', this.keystorePath, '-storepass', this.keystorePassword]));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        keystoreHash = md5re.exec(stdout);

        keystoreHash = keystoreHash ? keystoreHash[1] : null;
        _loggerJs2['default'].debug('Keystore MD5: ' + keystoreHash);
        return context$1$0.abrupt('return', keystoreHash);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](1);
        throw new Error('getKeystoreMd5 failed. Original error: ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 12]]);
};

/**
 * Check if the MD5 hash of the particular application matches to the given hash.
 *
 * @param {string} keytool - The name of the keytool utility.
 * @param {RegExp} md5re - The pattern used to match the result in _keytool_ output.
 * @param {string} keystoreHash - The expected hash value.
 * @param {string} pkg - The name of the installed package.
 * @param {string} apk - The full path to the existing apk file.
 * @return {boolean} True if both hashes are equal.
 * @throws {Error} If getting keystore MD5 hash fails.
 */
apkSigningMethods.checkApkKeystoreMatch = function callee$0$0(keytool, md5re, keystoreHash, pkg, apk) {
  var entryHash, rsa, foundKeystoreMatch;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        entryHash = null;
        rsa = /^META-INF\/.*\.[rR][sS][aA]$/;
        foundKeystoreMatch = false;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.zip.readEntries(apk, function callee$1$0(_ref3) {
          var entry = _ref3.entry;
          var extractEntryTo = _ref3.extractEntryTo;

          var entryPath, entryFile, _ref4, stdout, matchesKeystore;

          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                entry = entry.fileName;

                if (rsa.test(entry)) {
                  context$2$0.next = 3;
                  break;
                }

                return context$2$0.abrupt('return');

              case 3:
                _loggerJs2['default'].debug('Entry: ' + entry);
                entryPath = _path2['default'].join(this.tmpDir, pkg, 'cert');

                _loggerJs2['default'].debug('entryPath: ' + entryPath);
                entryFile = _path2['default'].join(entryPath, entry);

                _loggerJs2['default'].debug('entryFile: ' + entryFile);
                // ensure /tmp/pkg/cert/ doesn't exist or extract will fail.
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(entryPath));

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap(extractEntryTo(entryPath));

              case 12:
                _loggerJs2['default'].debug("extracted!");
                // check for match
                _loggerJs2['default'].debug("Printing apk md5.");
                context$2$0.next = 16;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(keytool, ['-v', '-printcert', '-file', entryFile]));

              case 16:
                _ref4 = context$2$0.sent;
                stdout = _ref4.stdout;

                entryHash = md5re.exec(stdout);
                entryHash = entryHash ? entryHash[1] : null;
                _loggerJs2['default'].debug('entryHash MD5: ' + entryHash);
                _loggerJs2['default'].debug('keystore MD5: ' + keystoreHash);
                matchesKeystore = entryHash && entryHash === keystoreHash;

                _loggerJs2['default'].debug('Matches keystore? ' + matchesKeystore);

                // If we have a keystore match, stop iterating

                if (!matchesKeystore) {
                  context$2$0.next = 27;
                  break;
                }

                foundKeystoreMatch = true;
                return context$2$0.abrupt('return', false);

              case 27:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3);
        }));

      case 5:
        return context$1$0.abrupt('return', foundKeystoreMatch);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

exports['default'] = apkSigningMethods;
module.exports = exports['default'];

// it is necessary to apply zipalign only before signing
// if apksigner is used or only after signing if we only have
// sign.jar utility

//for (let entry of entries) {
// META-INF/CERT.RSA
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9hcGstc2lnbmluZy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7c0JBQWMsUUFBUTs7Ozs0QkFDRCxjQUFjOztvQkFDbEIsTUFBTTs7Ozt3QkFDUCxjQUFjOzs7OzZCQUNtQixnQkFBZ0I7O3lCQUNLLGVBQWU7O0FBRXJGLElBQU0sbUJBQW1CLEdBQUcsa0JBQUssT0FBTyxxQkFBVSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDekUsSUFBTSxtQkFBbUIsR0FBRyxrQkFBSyxPQUFPLHFCQUFVLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0FBQzlFLElBQU0sbUJBQW1CLEdBQUcsa0VBQWtFLENBQUM7O0FBRS9GLElBQUksaUJBQWlCLEdBQUcsRUFBRSxDQUFDOzs7Ozs7Ozs7O0FBVTNCLFNBQWUsY0FBYyxDQUFFLFlBQVk7TUFDbkMsZUFBZSxFQUNmLGNBQWMsRUFNZCxXQUFXOzs7Ozt5Q0FQYSxrQkFBRyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQzs7O0FBQTFELHVCQUFlO0FBQ2Ysc0JBQWMsR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLGtDQUFrQyxFQUMvRSx5QkFBeUIsQ0FBQzs7Y0FDeEIsY0FBYyxLQUFLLGVBQWUsQ0FBQTs7Ozs7NENBQzdCLFlBQVk7OztBQUVyQiw4QkFBSSxLQUFLLGlCQUFjLFlBQVksU0FBTSxDQUFDOzt5Q0FDaEIsdUJBQVEsSUFBSSxDQUFDLEVBQUMsTUFBTSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDLENBQUM7OztBQUF2RSxtQkFBVzs7eUNBQ1gsMkJBQU8sa0JBQUssT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7O3lDQUNqQyxrQkFBRyxTQUFTLENBQUMsV0FBVyxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUM7Ozs0Q0FDakQsV0FBVzs7Ozs7OztDQUNuQjs7Ozs7Ozs7OztBQVVELGlCQUFpQixDQUFDLGdCQUFnQixHQUFHO01BQWdCLElB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Ozs7OztTQUVmLENBQUM7Ozs0Q0FDSyxrQkFBa0I7Ozs7Ozs7Q0FDMUIsQ0FBQzs7cUJBRWEsaUJBQWlCIiwiZmlsZSI6ImxpYi90b29scy9hcGstc2lnbmluZy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IHsgdGVtcERpciwgc3lzdGVtLCBta2RpcnAsIGZzLCB6aXAgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgeyBnZXRKYXZhRm9yT3MsIGdldEFwa3NpZ25lckZvck9zLCBnZXRKYXZhSG9tZSwgcm9vdERpciB9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xuXG5jb25zdCBERUZBVUxUX1BSSVZBVEVfS0VZID0gcGF0aC5yZXNvbHZlKHJvb3REaXIsICdrZXlzJywgJ3Rlc3RrZXkucGs4Jyk7XG5jb25zdCBERUZBVUxUX0NFUlRJRklDQVRFID0gcGF0aC5yZXNvbHZlKHJvb3REaXIsICdrZXlzJywgJ3Rlc3RrZXkueDUwOS5wZW0nKTtcbmNvbnN0IERFRkFVTFRfQ0VSVF9ESUdFU1QgPSAnYTQwZGE4MGE1OWQxNzBjYWE5NTBjZjE1YzE4YzQ1NGQ0N2EzOWIyNjk4OWQ4YjY0MGVjZDc0NWJhNzFiZjVkYyc7XG5cbmxldCBhcGtTaWduaW5nTWV0aG9kcyA9IHt9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHBhdGNoLCB3aGljaCB3b3JrYXJvdW5kcyctRGphdmEuZXh0LmRpcnMgaXMgbm90IHN1cHBvcnRlZC4gVXNlIC1jbGFzc3BhdGggaW5zdGVhZC4nXG4gKiBlcnJvciBvbiBXaW5kb3dzIGJ5IGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHBhdGNoZWQgY29weSBvZiB0aGUgb3JpZ2luYWwgYXBrc2lnbmVyIHNjcmlwdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luYWxQYXRoIC0gVGhlIG9yaWdpbmFsIHBhdGggdG8gYXBrc2lnbmVyIHRvb2xcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmdWxsIHBhdGggdG8gdGhlIHBhdGNoZWQgc2NyaXB0IG9yIHRoZSBzYW1lIHBhdGggaWYgdGhlcmUgaXNcbiAqICAgICAgICAgICAgICAgICAgIG5vIG5lZWQgdG8gcGF0Y2ggdGhlIG9yaWdpbmFsIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhdGNoQXBrc2lnbmVyIChvcmlnaW5hbFBhdGgpIHtcbiAgY29uc3Qgb3JpZ2luYWxDb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUob3JpZ2luYWxQYXRoLCAnYXNjaWknKTtcbiAgY29uc3QgcGF0Y2hlZENvbnRlbnQgPSBvcmlnaW5hbENvbnRlbnQucmVwbGFjZSgnLURqYXZhLmV4dC5kaXJzPVwiJWZyYW1ld29ya2RpciVcIicsXG4gICAgJy1jcCBcIiVmcmFtZXdvcmtkaXIlXFxcXCpcIicpO1xuICBpZiAocGF0Y2hlZENvbnRlbnQgPT09IG9yaWdpbmFsQ29udGVudCkge1xuICAgIHJldHVybiBvcmlnaW5hbFBhdGg7XG4gIH1cbiAgbG9nLmRlYnVnKGBQYXRjaGluZyAnJHtvcmlnaW5hbFBhdGh9Li4uYCk7XG4gIGNvbnN0IHBhdGNoZWRQYXRoID0gYXdhaXQgdGVtcERpci5wYXRoKHtwcmVmaXg6ICdhcGtzaWduZXInLCBzdWZmaXg6ICcuYmF0J30pO1xuICBhd2FpdCBta2RpcnAocGF0aC5kaXJuYW1lKHBhdGNoZWRQYXRoKSk7XG4gIGF3YWl0IGZzLndyaXRlRmlsZShwYXRjaGVkUGF0aCwgcGF0Y2hlZENvbnRlbnQsICdhc2NpaScpO1xuICByZXR1cm4gcGF0Y2hlZFBhdGg7XG59XG5cbi8qKlxuICogRXhlY3V0ZSBhcGtzaWduZXIgdXRpbGl0eSB3aXRoIGdpdmVuIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gez9BcnJheTxTdHJpbmc+fSBhcmdzIC0gVGhlIGxpc3Qgb2YgdG9vbCBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCBzdGRvdXRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhcGtzaWduZXIgYmluYXJ5IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbVxuICogICAgICAgICAgICAgICAgIG9yIHRoZSByZXR1cm4gY29kZSBpcyBub3QgZXF1YWwgdG8gemVyby5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuZXhlY3V0ZUFwa3NpZ25lciA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzID0gW10pIHtcbiAgY29uc3QgYXBrU2lnbmVyID0gYXdhaXQgZ2V0QXBrc2lnbmVyRm9yT3ModGhpcyk7XG4gIGNvbnN0IG9yaWdpbmFsRm9sZGVyID0gcGF0aC5kaXJuYW1lKGFwa1NpZ25lcik7XG4gIGNvbnN0IGdldEFwa3NpZ25lck91dHB1dCA9IGFzeW5jIChhcGtzaWduZXJQYXRoKSA9PiB7XG4gICAgY29uc3Qge3N0ZG91dCwgc3RkZXJyfSA9IGF3YWl0IGV4ZWMoYXBrc2lnbmVyUGF0aCwgYXJncywge1xuICAgICAgY3dkOiBvcmlnaW5hbEZvbGRlcixcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBzdHJlYW1dIG9mIFtbJ3N0ZG91dCcsIHN0ZG91dF0sIFsnc3RkZXJyJywgc3RkZXJyXV0pIHtcbiAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgbG9nLmRlYnVnKGBhcGtzaWduZXIgJHtuYW1lfTogJHtzdHJlYW19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGRvdXQ7XG4gIH07XG4gIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgJyR7YXBrU2lnbmVyfScgd2l0aCBhcmdzICcke0pTT04uc3RyaW5naWZ5KGFyZ3MpfSdgKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZ2V0QXBrc2lnbmVyT3V0cHV0KGFwa1NpZ25lcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBHb3QgYW4gZXJyb3IgZHVyaW5nIGFwa3NpZ25lciBleGVjdXRpb246ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgc3RyZWFtXSBvZiBbWydzdGRvdXQnLCBlcnIuc3Rkb3V0XSwgWydzdGRlcnInLCBlcnIuc3RkZXJyXV0pIHtcbiAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgbG9nLndhcm4oYGFwa3NpZ25lciAke25hbWV9OiAke3N0cmVhbX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgICAgY29uc3QgcGF0Y2hlZEFwa3NpZ25lciA9IGF3YWl0IHBhdGNoQXBrc2lnbmVyKGFwa1NpZ25lcik7XG4gICAgICBpZiAocGF0Y2hlZEFwa3NpZ25lciAhPT0gYXBrU2lnbmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFwa3NpZ25lck91dHB1dChwYXRjaGVkQXBrc2lnbmVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBhd2FpdCBmcy51bmxpbmsocGF0Y2hlZEFwa3NpZ25lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG4vKipcbiAqIChSZSlzaWduIHRoZSBnaXZlbiBhcGsgZmlsZSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gd2l0aCB0aGUgZGVmYXVsdCBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgYXBrIGZpbGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc2lnbmluZyBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuc2lnbldpdGhEZWZhdWx0Q2VydCA9IGFzeW5jIGZ1bmN0aW9uIChhcGspIHtcbiAgbG9nLmRlYnVnKGBTaWduaW5nICcke2Fwa30nIHdpdGggZGVmYXVsdCBjZXJ0YCk7XG4gIGlmICghKGF3YWl0IGZzLmV4aXN0cyhhcGspKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHthcGt9IGZpbGUgZG9lc24ndCBleGlzdC5gKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYXJncyA9IFsnc2lnbicsXG4gICAgICAnLS1rZXknLCBERUZBVUxUX1BSSVZBVEVfS0VZLFxuICAgICAgJy0tY2VydCcsIERFRkFVTFRfQ0VSVElGSUNBVEUsXG4gICAgICBhcGtdO1xuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUFwa3NpZ25lcihhcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYENhbm5vdCB1c2UgYXBrc2lnbmVyIHRvb2wgZm9yIHNpZ25pbmcuIERlZmF1bHRpbmcgdG8gc2lnbi5qYXIuIGAgK1xuICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gICsgKGVyci5zdGRlcnIgPyBgOyBTdGRFcnI6ICR7ZXJyLnN0ZGVycn1gIDogJycpKTtcbiAgICBjb25zdCBqYXZhID0gZ2V0SmF2YUZvck9zKCk7XG4gICAgY29uc3Qgc2lnblBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5oZWxwZXJKYXJQYXRoLCAnc2lnbi5qYXInKTtcbiAgICBsb2cuZGVidWcoXCJSZXNpZ25pbmcgYXBrLlwiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlYyhqYXZhLCBbJy1qYXInLCBzaWduUGF0aCwgYXBrLCAnLS1vdmVycmlkZSddKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBzaWduIHdpdGggZGVmYXVsdCBjZXJ0aWZpY2F0ZS4gT3JpZ2luYWwgZXJyb3IgJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIChSZSlzaWduIHRoZSBnaXZlbiBhcGsgZmlsZSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gd2l0aCBhIGN1c3RvbSBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgYXBrIGZpbGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc2lnbmluZyBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuc2lnbldpdGhDdXN0b21DZXJ0ID0gYXN5bmMgZnVuY3Rpb24gKGFwaykge1xuICBsb2cuZGVidWcoYFNpZ25pbmcgJyR7YXBrfScgd2l0aCBjdXN0b20gY2VydGApO1xuICBpZiAoIShhd2FpdCBmcy5leGlzdHModGhpcy5rZXlzdG9yZVBhdGgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvcmU6ICR7dGhpcy5rZXlzdG9yZVBhdGh9IGRvZXNuJ3QgZXhpc3QuYCk7XG4gIH1cbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKGFwaykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthcGt9JyBkb2Vzbid0IGV4aXN0LmApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhcmdzID0gWydzaWduJyxcbiAgICAgICctLWtzJywgdGhpcy5rZXlzdG9yZVBhdGgsXG4gICAgICAnLS1rcy1rZXktYWxpYXMnLCB0aGlzLmtleUFsaWFzLFxuICAgICAgJy0ta3MtcGFzcycsIGBwYXNzOiR7dGhpcy5rZXlzdG9yZVBhc3N3b3JkfWAsXG4gICAgICAnLS1rZXktcGFzcycsIGBwYXNzOiR7dGhpcy5rZXlQYXNzd29yZH1gLFxuICAgICAgYXBrXTtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGVBcGtzaWduZXIoYXJncyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgdXNlIGFwa3NpZ25lciB0b29sIGZvciBzaWduaW5nLiBEZWZhdWx0aW5nIHRvIGphcnNpZ25lci4gYCArXG4gICAgICAgICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHRyeSB7XG4gICAgICBsb2cuZGVidWcoXCJVbnNpZ25pbmcgYXBrLlwiKTtcbiAgICAgIGF3YWl0IGV4ZWMoZ2V0SmF2YUZvck9zKCksIFsnLWphcicsIHBhdGgucmVzb2x2ZSh0aGlzLmhlbHBlckphclBhdGgsICd1bnNpZ24uamFyJyksIGFwa10pO1xuICAgICAgbG9nLmRlYnVnKFwiU2lnbmluZyBhcGsuXCIpO1xuICAgICAgY29uc3QgamFyc2lnbmVyID0gcGF0aC5yZXNvbHZlKGdldEphdmFIb21lKCksICdiaW4nLCBgamFyc2lnbmVyJHtzeXN0ZW0uaXNXaW5kb3dzKCkgPyAnLmV4ZScgOiAnJ31gKTtcbiAgICAgIGF3YWl0IGV4ZWMoamFyc2lnbmVyLCBbJy1zaWdhbGcnLCAnTUQ1d2l0aFJTQScsICctZGlnZXN0YWxnJywgJ1NIQTEnLFxuICAgICAgICAnLWtleXN0b3JlJywgdGhpcy5rZXlzdG9yZVBhdGgsICctc3RvcmVwYXNzJywgdGhpcy5rZXlzdG9yZVBhc3N3b3JkLFxuICAgICAgICAnLWtleXBhc3MnLCB0aGlzLmtleVBhc3N3b3JkLCBhcGssIHRoaXMua2V5QWxpYXNdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBzaWduIHdpdGggY3VzdG9tIGNlcnRpZmljYXRlLiBPcmlnaW5hbCBlcnJvciAke2UubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogKFJlKXNpZ24gdGhlIGdpdmVuIGFwayBmaWxlIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSB3aXRoIGVpdGhlclxuICogY3VzdG9tIG9yIGRlZmF1bHQgY2VydGlmaWNhdGUgYmFzZWQgb24gX3RoaXMudXNlS2V5c3RvcmVfIHByb3BlcnR5IHZhbHVlXG4gKiBhbmQgWmlwLWFsaWducyBpdCBhZnRlciBzaWduaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBsb2NhbCBhcGsgZmlsZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzaWduaW5nIGZhaWxzLlxuICovXG5hcGtTaWduaW5nTWV0aG9kcy5zaWduID0gYXN5bmMgZnVuY3Rpb24gKGFwaykge1xuICBsZXQgYXBrc2lnbmVyRm91bmQgPSB0cnVlO1xuICB0cnkge1xuICAgIGF3YWl0IGdldEFwa3NpZ25lckZvck9zKHRoaXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhcGtzaWduZXJGb3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGFwa3NpZ25lckZvdW5kKSB7XG4gICAgLy8gaXQgaXMgbmVjZXNzYXJ5IHRvIGFwcGx5IHppcGFsaWduIG9ubHkgYmVmb3JlIHNpZ25pbmdcbiAgICAvLyBpZiBhcGtzaWduZXIgaXMgdXNlZCBvciBvbmx5IGFmdGVyIHNpZ25pbmcgaWYgd2Ugb25seSBoYXZlXG4gICAgLy8gc2lnbi5qYXIgdXRpbGl0eVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnppcEFsaWduQXBrKGFwayk7XG4gICAgfSBjYXRjaCAoaWduKSB7fVxuICB9XG5cbiAgaWYgKHRoaXMudXNlS2V5c3RvcmUpIHtcbiAgICBhd2FpdCB0aGlzLnNpZ25XaXRoQ3VzdG9tQ2VydChhcGspO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IHRoaXMuc2lnbldpdGhEZWZhdWx0Q2VydChhcGspO1xuICB9XG5cbiAgaWYgKCFhcGtzaWduZXJGb3VuZCkge1xuICAgIGF3YWl0IHRoaXMuemlwQWxpZ25BcGsoYXBrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtIHppcC1hbGlnbmluZyB0byB0aGUgZ2l2ZW4gbG9jYWwgYXBrIGZpbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFwayAtIFRoZSBmdWxsIHBhdGggdG8gdGhlIGxvY2FsIGFwayBmaWxlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHppcC1hbGlnbiBmYWlscy5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuemlwQWxpZ25BcGsgPSBhc3luYyBmdW5jdGlvbiAoYXBrKSB7XG4gIGxvZy5kZWJ1ZyhgWmlwLWFsaWduaW5nICcke2Fwa30nYCk7XG4gIGF3YWl0IHRoaXMuaW5pdFppcEFsaWduKCk7XG4gIGxldCBhbGlnbmVkQXBrID0gYXdhaXQgdGVtcERpci5wYXRoKHtwcmVmaXg6ICdhcHBpdW0nLCBzdWZmaXg6ICcudG1wJ30pO1xuICBhd2FpdCBta2RpcnAocGF0aC5kaXJuYW1lKGFsaWduZWRBcGspKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuYmluYXJpZXMuemlwYWxpZ24sIFsnLWYnLCAnNCcsIGFwaywgYWxpZ25lZEFwa10pO1xuICAgIGF3YWl0IGZzLm12KGFsaWduZWRBcGssIGFwaywgeyBta2RpcnA6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGFsaWduZWRBcGspKSB7XG4gICAgICBhd2FpdCBmcy51bmxpbmsoYWxpZ25lZEFwayk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgemlwQWxpZ25BcGsgZmFpbGVkLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9LiBTdGRvdXQ6ICcke2Uuc3Rkb3V0fSc7IFN0ZGVycjogJyR7ZS5zdGRlcnJ9J2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBhcHAgaXMgYWxyZWFkeSBzaWduZWQgd2l0aCB0aGUgZGVmYXVsdCBBcHBpdW0gY2VyaXRmaWNhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFwayAtIFRoZSBmdWxsIHBhdGggdG8gdGhlIGxvY2FsIGFwayBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBnayAtIFRoZSBuYW1lIG9mIGFwcGxpY2F0aW9uIHBhY2thZ2UuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGdpdmVuIGFwcGxpY2F0aW9uIGlzIGFscmVhZHkgc2lnbmVkLlxuICovXG5hcGtTaWduaW5nTWV0aG9kcy5jaGVja0Fwa0NlcnQgPSBhc3luYyBmdW5jdGlvbiAoYXBrLCBwa2cpIHtcbiAgbG9nLmRlYnVnKGBDaGVja2luZyBhcHAgY2VydCBmb3IgJHthcGt9YCk7XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKGFwaykpIHtcbiAgICBsb2cuZGVidWcoYCcke2Fwa30nIGRvZXNuJ3QgZXhpc3RgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMudXNlS2V5c3RvcmUpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5jaGVja0N1c3RvbUFwa0NlcnQoYXBrLCBwa2cpO1xuICB9XG5cbiAgbGV0IHZlcmlmaWNhdGlvbkZ1bmM7XG4gIHRyeSB7XG4gICAgYXdhaXQgZ2V0QXBrc2lnbmVyRm9yT3ModGhpcyk7XG4gICAgdmVyaWZpY2F0aW9uRnVuYyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuZXhlY3V0ZUFwa3NpZ25lcihbJ3ZlcmlmeScsICctLXByaW50LWNlcnRzJywgYXBrXSk7XG4gICAgICBpZiAoIV8uaW5jbHVkZXMob3V0cHV0LCBERUZBVUxUX0NFUlRfRElHRVNUKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Fwa30nIGlzIHNpZ25lZCB3aXRoIG5vbi1kZWZhdWx0IGNlcnRpZmljYXRlYCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy53YXJuKGBDYW5ub3QgdXNlIGFwa3NpZ25lciB0b29sIGZvciBzaWduYXR1cmUgdmVyaWZpY2F0aW9uLiBEZWZhdWx0aW5nIHRvIHZlcmlmeS5qYXIuIGAgK1xuICAgICAgYE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICBjb25zdCBqYXZhID0gZ2V0SmF2YUZvck9zKCk7XG4gICAgdmVyaWZpY2F0aW9uRnVuYyA9IGFzeW5jICgpID0+IGF3YWl0IGV4ZWMoamF2YSwgWyctamFyJywgcGF0aC5yZXNvbHZlKHRoaXMuaGVscGVySmFyUGF0aCwgJ3ZlcmlmeS5qYXInKSwgYXBrXSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCB2ZXJpZmljYXRpb25GdW5jKCk7XG4gICAgbG9nLmRlYnVnKGAnJHthcGt9JyBpcyBhbHJlYWR5IHNpZ25lZC5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5kZWJ1ZyhgJyR7YXBrfScgaXMgbm90IHNpZ25lZCB3aXRoIGRlYnVnIGNlcnQuYCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBhcHAgaXMgYWxyZWFkeSBzaWduZWQgd2l0aCBhIGN1c3RvbSBjZXJ0aWZpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXBrIC0gVGhlIGZ1bGwgcGF0aCB0byB0aGUgbG9jYWwgYXBrIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGdrIC0gVGhlIG5hbWUgb2YgYXBwbGljYXRpb24gcGFja2FnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZ2l2ZW4gYXBwbGljYXRpb24gaXMgYWxyZWFkeSBzaWduZWQgd2l0aCBhIGN1c3RvbSBjZXJ0aWZpY2F0ZS5cbiAqL1xuYXBrU2lnbmluZ01ldGhvZHMuY2hlY2tDdXN0b21BcGtDZXJ0ID0gYXN5bmMgZnVuY3Rpb24gKGFwaywgcGtnKSB7XG4gIGxvZy5kZWJ1ZyhgQ2hlY2tpbmcgY3VzdG9tIGFwcCBjZXJ0IGZvciAke2Fwa31gKTtcbiAgbGV0IGggPSBcImEtZkEtRjAtOVwiO1xuICBsZXQgbWQ1U3RyID0gW2AuKk1ENS4qKCg/Olske2h9XXsyfTopezE1fVske2h9XXsyfSlgXTtcbiAgbGV0IG1kNSA9IG5ldyBSZWdFeHAobWQ1U3RyLCAnbWknKTtcbiAgbGV0IGphdmFIb21lID0gZ2V0SmF2YUhvbWUoKTtcbiAgbGV0IGtleXRvb2wgPSBwYXRoLnJlc29sdmUoamF2YUhvbWUsICdiaW4nLCBga2V5dG9vbCR7c3lzdGVtLmlzV2luZG93cygpID8gJy5leGUnIDogJyd9YCk7XG4gIGxldCBrZXlzdG9yZUhhc2ggPSBhd2FpdCB0aGlzLmdldEtleXN0b3JlTWQ1KGtleXRvb2wsIG1kNSk7XG4gIHJldHVybiBhd2FpdCB0aGlzLmNoZWNrQXBrS2V5c3RvcmVNYXRjaChrZXl0b29sLCBtZDUsIGtleXN0b3JlSGFzaCwgcGtnLCBhcGspO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIE1ENSBoYXNoIG9mIHRoZSBrZXlzdG9yZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5dG9vbCAtIFRoZSBuYW1lIG9mIHRoZSBrZXl0b29sIHV0aWxpdHkuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gbWQ1cmUgLSBUaGUgcGF0dGVybiB1c2VkIHRvIG1hdGNoIHRoZSByZXN1bHQgaW4gX2tleXRvb2xfIG91dHB1dC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleXN0b3JlIE1ENSBoYXNoIG9yIF9udWxsXyBpZiB0aGUgaGFzaCBjYW5ub3QgYmUgcGFyc2VkLlxuICogQHRocm93cyB7RXJyb3J9IElmIGdldHRpbmcga2V5c3RvcmUgTUQ1IGhhc2ggZmFpbHMuXG4gKi9cbmFwa1NpZ25pbmdNZXRob2RzLmdldEtleXN0b3JlTWQ1ID0gYXN5bmMgZnVuY3Rpb24gKGtleXRvb2wsIG1kNXJlKSB7XG4gIGxvZy5kZWJ1ZyhcIlByaW50aW5nIGtleXN0b3JlIG1kNS5cIik7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhrZXl0b29sLCBbJy12JywgJy1saXN0JyxcbiAgICAgICctYWxpYXMnLCB0aGlzLmtleUFsaWFzLFxuICAgICAgJy1rZXlzdG9yZScsIHRoaXMua2V5c3RvcmVQYXRoLFxuICAgICAgJy1zdG9yZXBhc3MnLCB0aGlzLmtleXN0b3JlUGFzc3dvcmRdKTtcbiAgICBsZXQga2V5c3RvcmVIYXNoID0gbWQ1cmUuZXhlYyhzdGRvdXQpO1xuICAgIGtleXN0b3JlSGFzaCA9IGtleXN0b3JlSGFzaCA/IGtleXN0b3JlSGFzaFsxXSA6IG51bGw7XG4gICAgbG9nLmRlYnVnKGBLZXlzdG9yZSBNRDU6ICR7a2V5c3RvcmVIYXNofWApO1xuICAgIHJldHVybiBrZXlzdG9yZUhhc2g7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGdldEtleXN0b3JlTWQ1IGZhaWxlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBNRDUgaGFzaCBvZiB0aGUgcGFydGljdWxhciBhcHBsaWNhdGlvbiBtYXRjaGVzIHRvIHRoZSBnaXZlbiBoYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl0b29sIC0gVGhlIG5hbWUgb2YgdGhlIGtleXRvb2wgdXRpbGl0eS5cbiAqIEBwYXJhbSB7UmVnRXhwfSBtZDVyZSAtIFRoZSBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2ggdGhlIHJlc3VsdCBpbiBfa2V5dG9vbF8gb3V0cHV0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleXN0b3JlSGFzaCAtIFRoZSBleHBlY3RlZCBoYXNoIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBrZyAtIFRoZSBuYW1lIG9mIHRoZSBpbnN0YWxsZWQgcGFja2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcGsgLSBUaGUgZnVsbCBwYXRoIHRvIHRoZSBleGlzdGluZyBhcGsgZmlsZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYm90aCBoYXNoZXMgYXJlIGVxdWFsLlxuICogQHRocm93cyB7RXJyb3J9IElmIGdldHRpbmcga2V5c3RvcmUgTUQ1IGhhc2ggZmFpbHMuXG4gKi9cbmFwa1NpZ25pbmdNZXRob2RzLmNoZWNrQXBrS2V5c3RvcmVNYXRjaCA9IGFzeW5jIGZ1bmN0aW9uIChrZXl0b29sLCBtZDVyZSwga2V5c3RvcmVIYXNoLFxuICAgIHBrZywgYXBrKSB7XG4gIGxldCBlbnRyeUhhc2ggPSBudWxsO1xuICBsZXQgcnNhID0gL15NRVRBLUlORlxcLy4qXFwuW3JSXVtzU11bYUFdJC87XG4gIGxldCBmb3VuZEtleXN0b3JlTWF0Y2ggPSBmYWxzZTtcblxuICAvL2ZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgYXdhaXQgemlwLnJlYWRFbnRyaWVzKGFwaywgYXN5bmMgKHtlbnRyeSwgZXh0cmFjdEVudHJ5VG99KSA9PiB7XG4gICAgZW50cnkgPSBlbnRyeS5maWxlTmFtZTtcbiAgICBpZiAoIXJzYS50ZXN0KGVudHJ5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2cuZGVidWcoYEVudHJ5OiAke2VudHJ5fWApO1xuICAgIGxldCBlbnRyeVBhdGggPSBwYXRoLmpvaW4odGhpcy50bXBEaXIsIHBrZywgJ2NlcnQnKTtcbiAgICBsb2cuZGVidWcoYGVudHJ5UGF0aDogJHtlbnRyeVBhdGh9YCk7XG4gICAgbGV0IGVudHJ5RmlsZSA9IHBhdGguam9pbihlbnRyeVBhdGgsIGVudHJ5KTtcbiAgICBsb2cuZGVidWcoYGVudHJ5RmlsZTogJHtlbnRyeUZpbGV9YCk7XG4gICAgLy8gZW5zdXJlIC90bXAvcGtnL2NlcnQvIGRvZXNuJ3QgZXhpc3Qgb3IgZXh0cmFjdCB3aWxsIGZhaWwuXG4gICAgYXdhaXQgZnMucmltcmFmKGVudHJ5UGF0aCk7XG4gICAgLy8gTUVUQS1JTkYvQ0VSVC5SU0FcbiAgICBhd2FpdCBleHRyYWN0RW50cnlUbyhlbnRyeVBhdGgpO1xuICAgIGxvZy5kZWJ1ZyhcImV4dHJhY3RlZCFcIik7XG4gICAgLy8gY2hlY2sgZm9yIG1hdGNoXG4gICAgbG9nLmRlYnVnKFwiUHJpbnRpbmcgYXBrIG1kNS5cIik7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhrZXl0b29sLCBbJy12JywgJy1wcmludGNlcnQnLCAnLWZpbGUnLCBlbnRyeUZpbGVdKTtcbiAgICBlbnRyeUhhc2ggPSBtZDVyZS5leGVjKHN0ZG91dCk7XG4gICAgZW50cnlIYXNoID0gZW50cnlIYXNoID8gZW50cnlIYXNoWzFdIDogbnVsbDtcbiAgICBsb2cuZGVidWcoYGVudHJ5SGFzaCBNRDU6ICR7ZW50cnlIYXNofWApO1xuICAgIGxvZy5kZWJ1Zyhga2V5c3RvcmUgTUQ1OiAke2tleXN0b3JlSGFzaH1gKTtcbiAgICBsZXQgbWF0Y2hlc0tleXN0b3JlID0gZW50cnlIYXNoICYmIGVudHJ5SGFzaCA9PT0ga2V5c3RvcmVIYXNoO1xuICAgIGxvZy5kZWJ1ZyhgTWF0Y2hlcyBrZXlzdG9yZT8gJHttYXRjaGVzS2V5c3RvcmV9YCk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEga2V5c3RvcmUgbWF0Y2gsIHN0b3AgaXRlcmF0aW5nXG4gICAgaWYgKG1hdGNoZXNLZXlzdG9yZSkge1xuICAgICAgZm91bmRLZXlzdG9yZU1hdGNoID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZm91bmRLZXlzdG9yZU1hdGNoO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYXBrU2lnbmluZ01ldGhvZHM7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
