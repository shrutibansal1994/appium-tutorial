'use strict';

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _loggerJs = require('../logger.js');

var _loggerJs2 = _interopRequireDefault(_loggerJs);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _appiumSupport = require('appium-support');

var _helpers = require('../helpers');

var _teen_process = require('teen_process');

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _shellQuote = require('shell-quote');

var systemCallMethods = {};

var DEFAULT_ADB_EXEC_TIMEOUT = 20000; // in milliseconds
var DEFAULT_ADB_REBOOT_RETRIES = 90;

var LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;
var PROTOCOL_FAULT_ERROR_REGEXP = new RegExp('protocol fault \\(no status\\)', 'i');
var DEVICE_NOT_FOUND_ERROR_REGEXP = new RegExp('error: device (\'.+\' )?not found', 'i');
var DEVICE_CONNECTING_ERROR_REGEXP = new RegExp('error: device still connecting', 'i');

var CERTS_ROOT = '/system/etc/security/cacerts';

/**
 * Retrieve full path to the given binary.
 *
 * @param {string} binaryName - The name of the binary.
 * @return {string} Full path to the given binary including current SDK root.
 */
systemCallMethods.getSdkBinaryPath = _lodash2['default'].memoize(function callee$0$0(binaryName) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].info('Checking whether ' + binaryName + ' is present');

        if (!this.sdkRoot) {
          context$1$0.next = 5;
          break;
        }

        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getBinaryFromSdkRoot(binaryName));

      case 4:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 5:
        _loggerJs2['default'].warn('The ANDROID_HOME environment variable is not set to the Android SDK ' + 'root directory path. ANDROID_HOME is required for compatibility ' + ('with SDK 23+. Checking along PATH for ' + binaryName + '.'));
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(this.getBinaryFromPath(binaryName));

      case 8:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 9:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
});

/**
 * Retrieve the name of the tool,
 * which prints full path to the given command shortcut.
 *
 * @return {string} Depending on the current platform this is
 *                  supposed to be either 'which' or 'where'.
 */
systemCallMethods.getCommandForOS = _lodash2['default'].memoize(function () {
  return _appiumSupport.system.isWindows() ? 'where' : 'which';
});

/**
 * Retrieve full binary name for the current operating system.
 *
 * @param {string} binaryName - simple binary name, for example 'android'.
 * @return {string} Formatted binary name depending on the current platform,
 *                  for example, 'android.bat' on Windows.
 */
systemCallMethods.getBinaryNameForOS = _lodash2['default'].memoize(function (binaryName) {
  if (!_appiumSupport.system.isWindows()) {
    return binaryName;
  }

  if (['android', 'apksigner', 'apkanalyzer'].indexOf(binaryName) >= 0 && !binaryName.toLowerCase().endsWith('.bat')) {
    return binaryName + '.bat';
  }
  if (!binaryName.toLowerCase().endsWith('.exe')) {
    return binaryName + '.exe';
  }
  return binaryName;
});

/**
 * Retrieve full path to the given binary.
 *
 * @param {string} binaryName - Simple name of a binary file.
 * @return {string} Full path to the given binary. The method tries
 *                  to enumerate all the known locations where the binary
 *                  might be located and stops the search as soon as the first
 *                  match is found on the local file system.
 * @throws {Error} If the binary with given name is not present at any
 *                 of known locations or Android SDK is not installed on the
 *                 local file system.
 */
systemCallMethods.getBinaryFromSdkRoot = _lodash2['default'].memoize(function callee$0$0(binaryName) {
  var binaryLoc, binaryLocs, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, loc;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;

        binaryName = this.getBinaryNameForOS(binaryName);
        binaryLocs = [_path2['default'].resolve(this.sdkRoot, "platform-tools", binaryName), _path2['default'].resolve(this.sdkRoot, "emulator", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", binaryName), _path2['default'].resolve(this.sdkRoot, "tools", "bin", binaryName)];
        context$1$0.t0 = _lodash2['default'];
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _helpers.getBuildToolsDirs)(this.sdkRoot));

      case 6:
        context$1$0.t1 = context$1$0.sent;

        context$1$0.t2 = function (dir) {
          return binaryLocs.push(_path2['default'].resolve(dir, binaryName));
        };

        context$1$0.t0.forEach.call(context$1$0.t0, context$1$0.t1, context$1$0.t2);
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 12;
        _iterator = _getIterator(binaryLocs);

      case 14:
        if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
          context$1$0.next = 24;
          break;
        }

        loc = _step.value;
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(loc));

      case 18:
        if (!context$1$0.sent) {
          context$1$0.next = 21;
          break;
        }

        binaryLoc = loc;
        return context$1$0.abrupt('break', 24);

      case 21:
        _iteratorNormalCompletion = true;
        context$1$0.next = 14;
        break;

      case 24:
        context$1$0.next = 30;
        break;

      case 26:
        context$1$0.prev = 26;
        context$1$0.t3 = context$1$0['catch'](12);
        _didIteratorError = true;
        _iteratorError = context$1$0.t3;

      case 30:
        context$1$0.prev = 30;
        context$1$0.prev = 31;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 33:
        context$1$0.prev = 33;

        if (!_didIteratorError) {
          context$1$0.next = 36;
          break;
        }

        throw _iteratorError;

      case 36:
        return context$1$0.finish(33);

      case 37:
        return context$1$0.finish(30);

      case 38:
        if (!_lodash2['default'].isNull(binaryLoc)) {
          context$1$0.next = 40;
          break;
        }

        throw new Error('Could not find ' + binaryName + ' in ' + binaryLocs + '. ' + ('Do you have the Android SDK installed at \'' + this.sdkRoot + '\'?'));

      case 40:
        binaryLoc = binaryLoc.trim();
        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + binaryLoc);
        return context$1$0.abrupt('return', binaryLoc);

      case 43:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[12, 26, 30, 38], [31,, 33, 37]]);
});

/**
 * Retrieve full path to a binary file using the standard system lookup tool.
 *
 * @param {string} binaryName - The name of the binary.
 * @return {string} Full path to the binary received from 'which'/'where'
 *                  output.
 * @throws {Error} If lookup tool returns non-zero return code.
 */
systemCallMethods.getBinaryFromPath = function callee$0$0(binaryName) {
  var binaryLoc, cmd, _ref, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        binaryLoc = null;
        cmd = this.getCommandForOS();
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, [binaryName]));

      case 5:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;

        _loggerJs2['default'].info('Using ' + binaryName + ' from ' + stdout);
        // TODO write a test for binaries with spaces.
        binaryLoc = stdout.trim();
        return context$1$0.abrupt('return', binaryLoc);

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](2);
        throw new Error('Could not find ' + binaryName + ' Please set the ANDROID_HOME ' + 'environment variable with the Android SDK root directory path.');

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 12]]);
};

/**
 * @typedef {Object} Device
 * @property {string} udid - The device udid.
 * @property {string} state - Current device state, as it is visible in
 *                            _adb devices -l_ output.
 */

/**
 * Retrieve the list of devices visible to adb.
 *
 * @return {Array.<Device>} The list of devices or an empty list if
 *                          no devices are connected.
 * @throws {Error} If there was an error while listing devices.
 */
systemCallMethods.getConnectedDevices = function callee$0$0() {
  var _ref2, stdout, startingIndex, devices, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, line, lineInfo;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting connected devices...");
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, this.executable.defaultArgs.concat(['devices'])));

      case 4:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        startingIndex = stdout.indexOf("List of devices");

        if (!(startingIndex === -1)) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unexpected output while trying to get devices. output was: ' + stdout);

      case 9:
        // slicing ouput we care about.
        stdout = stdout.slice(startingIndex);
        devices = [];
        _iteratorNormalCompletion2 = true;
        _didIteratorError2 = false;
        _iteratorError2 = undefined;
        context$1$0.prev = 14;

        for (_iterator2 = _getIterator(stdout.split("\n")); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          line = _step2.value;

          if (line.trim() !== "" && line.indexOf("List of devices") === -1 && line.indexOf("adb server") === -1 && line.indexOf("* daemon") === -1 && line.indexOf("offline") === -1) {
            lineInfo = line.split("\t");

            // state is either "device" or "offline", afaict
            devices.push({ udid: lineInfo[0], state: lineInfo[1] });
          }
        }
        context$1$0.next = 22;
        break;

      case 18:
        context$1$0.prev = 18;
        context$1$0.t0 = context$1$0['catch'](14);
        _didIteratorError2 = true;
        _iteratorError2 = context$1$0.t0;

      case 22:
        context$1$0.prev = 22;
        context$1$0.prev = 23;

        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }

      case 25:
        context$1$0.prev = 25;

        if (!_didIteratorError2) {
          context$1$0.next = 28;
          break;
        }

        throw _iteratorError2;

      case 28:
        return context$1$0.finish(25);

      case 29:
        return context$1$0.finish(22);

      case 30:
        _loggerJs2['default'].debug(devices.length + ' device(s) connected');
        return context$1$0.abrupt('return', devices);

      case 34:
        context$1$0.prev = 34;
        context$1$0.t1 = context$1$0['catch'](1);
        throw new Error('Error while getting connected devices. Original error: ' + context$1$0.t1.message);

      case 37:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 34], [14, 18, 22, 30], [23,, 25, 29]]);
};

/**
 * Retrieve the list of devices visible to adb within the given timeout.
 *
 * @param {number} timeoutMs - The maximum number of milliseconds to get at least
 *                             one list item.
 * @return {Array.<Device>} The list of connected devices.
 * @throws {Error} If no connected devices can be detected within the given timeout.
 */
systemCallMethods.getDevicesWithRetry = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, getDevices;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Trying to find a connected android device");

        getDevices = function getDevices() {
          var devices;
          return _regeneratorRuntime.async(function getDevices$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                if (!(Date.now() - start > timeoutMs)) {
                  context$2$0.next = 2;
                  break;
                }

                throw new Error("Could not find a connected Android device.");

              case 2:
                context$2$0.prev = 2;
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 5:
                devices = context$2$0.sent;

                if (!(devices.length < 1)) {
                  context$2$0.next = 15;
                  break;
                }

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 10:
                context$2$0.next = 12;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 12:
                context$2$0.next = 14;
                return _regeneratorRuntime.awrap(getDevices());

              case 14:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 15:
                return context$2$0.abrupt('return', devices);

              case 18:
                context$2$0.prev = 18;
                context$2$0.t0 = context$2$0['catch'](2);

                _loggerJs2['default'].debug("Could not find devices, restarting adb server...");
                context$2$0.next = 23;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 23:
                context$2$0.next = 25;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

              case 25:
                context$2$0.next = 27;
                return _regeneratorRuntime.awrap(getDevices());

              case 27:
                return context$2$0.abrupt('return', context$2$0.sent);

              case 28:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this, [[2, 18]]);
        };

        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(getDevices());

      case 5:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Restart adb server if _this.suppressKillServer_ property is true.
 */
systemCallMethods.restartAdb = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!this.suppressKillServer) {
          context$1$0.next = 3;
          break;
        }

        _loggerJs2['default'].debug('Not restarting abd since \'suppressKillServer\' is on');
        return context$1$0.abrupt('return');

      case 3:

        _loggerJs2['default'].debug('Restarting adb');
        context$1$0.prev = 4;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.killServer());

      case 7:
        context$1$0.next = 12;
        break;

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](4);

        _loggerJs2['default'].error("Error killing ADB server, going to see if it's online anyway");

      case 12:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[4, 9]]);
};

/**
 * Kill adb server.
 */
systemCallMethods.killServer = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Killing adb server on port ' + this.adbPort);
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, [].concat(_toConsumableArray(this.executable.defaultArgs), ['kill-server'])));

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Reset Telnet authentication token.
 * @see {@link http://tools.android.com/recent/emulator2516releasenotes} for more details.
 *
 * @returns {boolean} If token reset was successful.
 */
systemCallMethods.resetTelnetAuthToken = _lodash2['default'].memoize(function callee$0$0() {
  var homeFolderPath, dstPath;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        homeFolderPath = process.env[process.platform === 'win32' ? 'USERPROFILE' : 'HOME'];

        if (homeFolderPath) {
          context$1$0.next = 4;
          break;
        }

        _loggerJs2['default'].warn('Cannot find the path to user home folder. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 4:
        dstPath = _path2['default'].resolve(homeFolderPath, '.emulator_console_auth_token');

        _loggerJs2['default'].debug('Overriding ' + dstPath + ' with an empty string to avoid telnet authentication for emulator commands');
        context$1$0.prev = 6;
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstPath, ''));

      case 9:
        context$1$0.next = 15;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](6);

        _loggerJs2['default'].warn('Error ' + context$1$0.t0.message + ' while resetting the content of ' + dstPath + '. Ignoring resetting of emulator\'s telnet authentication token');
        return context$1$0.abrupt('return', false);

      case 15:
        return context$1$0.abrupt('return', true);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[6, 11]]);
});

/**
 * Execute the given emulator command using _adb emu_ tool.
 *
 * @param {Array.<string>} cmd - The array of rest command line parameters.
 */
systemCallMethods.adbExecEmu = function callee$0$0(cmd) {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.verifyEmulatorConnected());

      case 2:
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.resetTelnetAuthToken());

      case 4:
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.adbExec(['emu'].concat(_toConsumableArray(cmd))));

      case 6:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute the given adb command.
 *
 * @param {Array.<string>} cmd - The array of rest command line parameters
 *                      or a single string parameter.
 * @param {Object} opts - Additional options mapping. See
 *                        {@link https://github.com/appium/node-teen_process}
 *                        for more details.
 * @return {string} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.adbExec = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var execFunc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this2 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (cmd) {
          context$1$0.next = 2;
          break;
        }

        throw new Error("You need to pass in a command to adbExec()");

      case 2:
        // setting default timeout for each command to prevent infinite wait.
        opts.timeout = opts.timeout || this.execTimeout || DEFAULT_ADB_EXEC_TIMEOUT;

        execFunc = function execFunc() {
          var args, _ref3, stdout, errText, protocolFaultError, deviceNotFoundError, deviceConnectingError;

          return _regeneratorRuntime.async(function execFunc$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;

                if (!(cmd instanceof Array)) {
                  cmd = [cmd];
                }
                args = this.executable.defaultArgs.concat(cmd);

                _loggerJs2['default'].debug('Running \'' + this.executable.path + ' ' + (0, _shellQuote.quote)(args) + '\'');
                context$2$0.next = 6;
                return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, args, opts));

              case 6:
                _ref3 = context$2$0.sent;
                stdout = _ref3.stdout;

                // sometimes ADB prints out weird stdout warnings that we don't want
                // to include in any of the response data, so let's strip it out
                stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 12:
                context$2$0.prev = 12;
                context$2$0.t0 = context$2$0['catch'](0);
                errText = context$2$0.t0.message + ', ' + context$2$0.t0.stdout + ', ' + context$2$0.t0.stderr;
                protocolFaultError = PROTOCOL_FAULT_ERROR_REGEXP.test(errText);
                deviceNotFoundError = DEVICE_NOT_FOUND_ERROR_REGEXP.test(errText);
                deviceConnectingError = DEVICE_CONNECTING_ERROR_REGEXP.test(errText);

                if (!(protocolFaultError || deviceNotFoundError || deviceConnectingError)) {
                  context$2$0.next = 24;
                  break;
                }

                _loggerJs2['default'].info('Error sending command, reconnecting device and retrying: ' + cmd);
                context$2$0.next = 22;
                return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(1000));

              case 22:
                context$2$0.next = 24;
                return _regeneratorRuntime.awrap(this.getDevicesWithRetry());

              case 24:
                if (!(context$2$0.t0.code === 0 && context$2$0.t0.stdout)) {
                  context$2$0.next = 28;
                  break;
                }

                stdout = context$2$0.t0.stdout;

                stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();
                return context$2$0.abrupt('return', stdout);

              case 28:
                throw new Error('Error executing adbExec. Original error: \'' + context$2$0.t0.message + '\'; ' + ('Stderr: \'' + (context$2$0.t0.stderr || '').trim() + '\'; Code: \'' + context$2$0.t0.code + '\''));

              case 29:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this2, [[0, 12]]);
        };

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(2, execFunc));

      case 6:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Execute the given command using _adb shell_ prefix.
 *
 * @param {Array.<string>|string} cmd - The array of rest command line parameters or a single
 *                                      string parameter.
 * @param {Object} opts - Additional options mapping. See
 *                        {@link https://github.com/appium/node-teen_process}
 *                        for more details.
 * @return {string} - Command's stdout.
 * @throws {Error} If the command returned non-zero exit code.
 */
systemCallMethods.shell = function callee$0$0(cmd) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.adbExec(_lodash2['default'].isArray(cmd) ? ['shell'].concat(_toConsumableArray(cmd)) : ['shell', cmd], opts));

      case 2:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 3:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

systemCallMethods.createSubProcess = function () {
  var args = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

  // add the default arguments
  args = this.executable.defaultArgs.concat(args);
  _loggerJs2['default'].debug('Creating ADB subprocess with args: ' + JSON.stringify(args));
  return new _teen_process.SubProcess(this.getAdbPath(), args);
};

/**
 * Retrieve the current adb port.
 * @todo can probably deprecate this now that the logic is just to read this.adbPort
 * @return {number} The current adb port number.
 */
systemCallMethods.getAdbServerPort = function () {
  return this.adbPort;
};

/**
 * Retrieve the current emulator port from _adb devives_ output.
 *
 * @return {number} The current emulator port.
 * @throws {Error} If there are no connected devices.
 */
systemCallMethods.getEmulatorPort = function callee$0$0() {
  var devices, port;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug("Getting running emulator port");

        if (!(this.emulatorPort !== null)) {
          context$1$0.next = 3;
          break;
        }

        return context$1$0.abrupt('return', this.emulatorPort);

      case 3:
        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 6:
        devices = context$1$0.sent;
        port = this.getPortFromEmulatorString(devices[0].udid);

        if (!port) {
          context$1$0.next = 12;
          break;
        }

        return context$1$0.abrupt('return', port);

      case 12:
        throw new Error('Emulator port not found');

      case 13:
        context$1$0.next = 18;
        break;

      case 15:
        context$1$0.prev = 15;
        context$1$0.t0 = context$1$0['catch'](3);
        throw new Error('No devices connected. Original error: ' + context$1$0.t0.message);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 15]]);
};

/**
 * Retrieve the current emulator port by parsing emulator name string.
 *
 * @param {string} emStr - Emulator name string.
 * @return {number|boolean} Either the current emulator port or
 *                          _false_ if port number cannot be parsed.
 */
systemCallMethods.getPortFromEmulatorString = function (emStr) {
  var portPattern = /emulator-(\d+)/;
  if (portPattern.test(emStr)) {
    return parseInt(portPattern.exec(emStr)[1], 10);
  }
  return false;
};

/**
 * Retrieve the list of currently connected emulators.
 *
 * @return {Array.<Device>} The list of connected devices.
 */
systemCallMethods.getConnectedEmulators = function callee$0$0() {
  var devices, emulators, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, device, port;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug("Getting connected emulators");
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedDevices());

      case 4:
        devices = context$1$0.sent;
        emulators = [];
        _iteratorNormalCompletion3 = true;
        _didIteratorError3 = false;
        _iteratorError3 = undefined;
        context$1$0.prev = 9;

        for (_iterator3 = _getIterator(devices); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          device = _step3.value;
          port = this.getPortFromEmulatorString(device.udid);

          if (port) {
            device.port = port;
            emulators.push(device);
          }
        }
        context$1$0.next = 17;
        break;

      case 13:
        context$1$0.prev = 13;
        context$1$0.t0 = context$1$0['catch'](9);
        _didIteratorError3 = true;
        _iteratorError3 = context$1$0.t0;

      case 17:
        context$1$0.prev = 17;
        context$1$0.prev = 18;

        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }

      case 20:
        context$1$0.prev = 20;

        if (!_didIteratorError3) {
          context$1$0.next = 23;
          break;
        }

        throw _iteratorError3;

      case 23:
        return context$1$0.finish(20);

      case 24:
        return context$1$0.finish(17);

      case 25:
        _loggerJs2['default'].debug(emulators.length + ' emulator(s) connected');
        return context$1$0.abrupt('return', emulators);

      case 29:
        context$1$0.prev = 29;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting emulators. Original error: ' + context$1$0.t1.message);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 29], [9, 13, 17, 25], [18,, 20, 24]]);
};

/**
 * Set _emulatorPort_ property of the current class.
 *
 * @param {number} emPort - The emulator port to be set.
 */
systemCallMethods.setEmulatorPort = function (emPort) {
  this.emulatorPort = emPort;
};

/**
 * Set the identifier of the current device (_this.curDeviceId_).
 *
 * @param {string} - The device identifier.
 */
systemCallMethods.setDeviceId = function (deviceId) {
  _loggerJs2['default'].debug('Setting device id to ' + deviceId);
  this.curDeviceId = deviceId;
  var argsHasDevice = this.executable.defaultArgs.indexOf('-s');
  if (argsHasDevice !== -1) {
    // remove the old device id from the arguments
    this.executable.defaultArgs.splice(argsHasDevice, 2);
  }
  this.executable.defaultArgs.push('-s', deviceId);
};

/**
 * Set the the current device object.
 *
 * @param {Device} deviceObj - The device object to be set.
 */
systemCallMethods.setDevice = function (deviceObj) {
  var deviceId = deviceObj.udid;
  var emPort = this.getPortFromEmulatorString(deviceId);
  this.setEmulatorPort(emPort);
  this.setDeviceId(deviceId);
};

/**
 * Get the object for the currently running emulator.
 *
 * @param {string} avdName - Emulator name.
 * @return {?Device} Currently running emulator or _null_.
 */
systemCallMethods.getRunningAVD = function callee$0$0(avdName) {
  var emulators, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, emulator, runningAVDName;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;

        _loggerJs2['default'].debug('Trying to find ' + avdName + ' emulator');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getConnectedEmulators());

      case 4:
        emulators = context$1$0.sent;
        _iteratorNormalCompletion4 = true;
        _didIteratorError4 = false;
        _iteratorError4 = undefined;
        context$1$0.prev = 8;
        _iterator4 = _getIterator(emulators);

      case 10:
        if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
          context$1$0.next = 23;
          break;
        }

        emulator = _step4.value;

        this.setEmulatorPort(emulator.port);
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.sendTelnetCommand("avd name"));

      case 15:
        runningAVDName = context$1$0.sent;

        if (!(avdName === runningAVDName)) {
          context$1$0.next = 20;
          break;
        }

        _loggerJs2['default'].debug('Found emulator ' + avdName + ' in port ' + emulator.port);
        this.setDeviceId(emulator.udid);
        return context$1$0.abrupt('return', emulator);

      case 20:
        _iteratorNormalCompletion4 = true;
        context$1$0.next = 10;
        break;

      case 23:
        context$1$0.next = 29;
        break;

      case 25:
        context$1$0.prev = 25;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError4 = true;
        _iteratorError4 = context$1$0.t0;

      case 29:
        context$1$0.prev = 29;
        context$1$0.prev = 30;

        if (!_iteratorNormalCompletion4 && _iterator4['return']) {
          _iterator4['return']();
        }

      case 32:
        context$1$0.prev = 32;

        if (!_didIteratorError4) {
          context$1$0.next = 35;
          break;
        }

        throw _iteratorError4;

      case 35:
        return context$1$0.finish(32);

      case 36:
        return context$1$0.finish(29);

      case 37:
        _loggerJs2['default'].debug('Emulator ' + avdName + ' not running');
        return context$1$0.abrupt('return', null);

      case 41:
        context$1$0.prev = 41;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting AVD. Original error: ' + context$1$0.t1.message);

      case 44:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 41], [8, 25, 29, 37], [30,, 32, 36]]);
};

/**
 * Get the object for the currently running emulator.
 *
 * @param {string} avdName - Emulator name.
 * @param {number} timeoutMs [20000] - The maximum number of milliseconds
 *                                     to wait until at least one running AVD object
 *                                     is detected.
 * @return {?Device} Currently running emulator or _null_.
 * @throws {Error} If no device has been detected within the timeout.
 */
systemCallMethods.getRunningAVDWithRetry = function callee$0$0(avdName) {
  var timeoutMs = arguments.length <= 1 || arguments[1] === undefined ? 20000 : arguments[1];
  var start, runningAVD;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        start = Date.now();

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 18;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName.replace('@', '')));

      case 6:
        runningAVD = context$1$0.sent;

        if (!runningAVD) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return', runningAVD);

      case 9:
        context$1$0.next = 14;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

        // Do nothing.
        _loggerJs2['default'].info('Couldn\'t get running AVD, will retry. Error was: ' + context$1$0.t0.message);

      case 14:
        context$1$0.next = 16;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(200));

      case 16:
        context$1$0.next = 2;
        break;

      case 18:
        throw new Error('Could not find ' + avdName + ' emulator.');

      case 21:
        context$1$0.prev = 21;
        context$1$0.t1 = context$1$0['catch'](0);
        throw new Error('Error getting AVD with retry. Original error: ' + context$1$0.t1.message);

      case 24:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 21], [3, 11]]);
};

/**
 * Shutdown all running emulators by killing their processes.
 *
 * @throws {Error} If killing tool returned non-zero return code.
 */
systemCallMethods.killAllEmulators = function callee$0$0() {
  var cmd, args;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, args = undefined;

        if (_appiumSupport.system.isWindows()) {
          cmd = 'TASKKILL';
          args = ['TASKKILL', '/IM', 'emulator.exe'];
        } else {
          cmd = '/usr/bin/killall';
          args = ['-m', 'emulator*'];
        }
        context$1$0.prev = 2;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args));

      case 5:
        context$1$0.next = 10;
        break;

      case 7:
        context$1$0.prev = 7;
        context$1$0.t0 = context$1$0['catch'](2);
        throw new Error('Error killing emulators. Original error: ' + context$1$0.t0.message);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[2, 7]]);
};

/**
 * Kill emulator with the given name. No error
 * is thrown is given avd does not exist/is not running.
 *
 * @param {?string} avdName - The name of the emulator to be killed. If empty,
 *                            the current emulator will be killed.
 * @return {boolean} - True if the emulator was killed, false otherwise.
 */
systemCallMethods.killEmulator = function callee$0$0(avdName) {
  var device;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        if (!_appiumSupport.util.hasValue(avdName)) {
          context$1$0.next = 10;
          break;
        }

        _loggerJs2['default'].debug('Killing avd \'' + avdName + '\'');
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getRunningAVD(avdName));

      case 4:
        device = context$1$0.sent;

        if (device) {
          context$1$0.next = 8;
          break;
        }

        _loggerJs2['default'].info('No avd with name \'' + avdName + '\' running. Skipping kill step.');
        return context$1$0.abrupt('return', false);

      case 8:
        context$1$0.next = 16;
        break;

      case 10:
        // killing the current avd
        _loggerJs2['default'].debug('Killing avd with id \'' + this.curDeviceId + '\'');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.isEmulatorConnected());

      case 13:
        if (context$1$0.sent) {
          context$1$0.next = 16;
          break;
        }

        _loggerJs2['default'].debug('Emulator with id \'' + this.curDeviceId + '\' not connected. Skipping kill step');
        return context$1$0.abrupt('return', false);

      case 16:
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(this.adbExec(['emu', 'kill']));

      case 18:
        _loggerJs2['default'].info('Successfully killed emulator');
        return context$1$0.abrupt('return', true);

      case 20:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Start an emulator with given parameters and wait until it is full started.
 *
 * @param {string} avdName - The name of an existing emulator.
 * @param {Array.<string>|string} avdArgs - Additional emulator command line argument.
 * @param {?string} language - Emulator system language.
 * @param {?contry} country - Emulator system country.
 * @param {number} avdLaunchTimeout [60000] - Emulator startup timeout in milliseconds.
 * @param {number} retryTimes [1] - The maximum number of startup retries.
 * @throws {Error} If the emulator fails to start within the given timeout.
 */
systemCallMethods.launchAVD = function callee$0$0(avdName, avdArgs, language, country) {
  var avdLaunchTimeout = arguments.length <= 4 || arguments[4] === undefined ? 60000 : arguments[4];
  var avdReadyTimeout = arguments.length <= 5 || arguments[5] === undefined ? 60000 : arguments[5];
  var retryTimes = arguments.length <= 6 || arguments[6] === undefined ? 1 : arguments[6];
  var emulatorBinaryPath, launchArgs, locale, proc;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        _loggerJs2['default'].debug('Launching Emulator with AVD ' + avdName + ', launchTimeout ' + (avdLaunchTimeout + 'ms and readyTimeout ' + avdReadyTimeout + 'ms'));
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath("emulator"));

      case 3:
        emulatorBinaryPath = context$1$0.sent;

        if (avdName[0] === "@") {
          avdName = avdName.substr(1);
        }
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap(this.checkAvdExist(avdName));

      case 7:
        launchArgs = ["-avd", avdName];

        if (_lodash2['default'].isString(language)) {
          _loggerJs2['default'].debug('Setting Android Device Language to ' + language);
          launchArgs.push("-prop", 'persist.sys.language=' + language.toLowerCase());
        }
        if (_lodash2['default'].isString(country)) {
          _loggerJs2['default'].debug('Setting Android Device Country to ' + country);
          launchArgs.push("-prop", 'persist.sys.country=' + country.toUpperCase());
        }
        locale = undefined;

        if (_lodash2['default'].isString(language) && _lodash2['default'].isString(country)) {
          locale = language.toLowerCase() + "-" + country.toUpperCase();
        } else if (_lodash2['default'].isString(language)) {
          locale = language.toLowerCase();
        } else if (_lodash2['default'].isString(country)) {
          locale = country;
        }
        if (_lodash2['default'].isString(locale)) {
          _loggerJs2['default'].debug('Setting Android Device Locale to ' + locale);
          launchArgs.push("-prop", 'persist.sys.locale=' + locale);
        }
        if (!_lodash2['default'].isEmpty(avdArgs)) {
          launchArgs.push.apply(launchArgs, _toConsumableArray(_lodash2['default'].isArray(avdArgs) ? avdArgs : avdArgs.split(' ')));
        }
        _loggerJs2['default'].debug('Running \'' + emulatorBinaryPath + '\' with args: ' + JSON.stringify(launchArgs));
        proc = new _teen_process.SubProcess(emulatorBinaryPath, launchArgs);
        context$1$0.next = 18;
        return _regeneratorRuntime.awrap(proc.start(0));

      case 18:
        proc.on('output', function (stdout, stderr) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = _getIterator((stdout || stderr || '').split('\n').filter(Boolean)), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var line = _step5.value;

              _loggerJs2['default'].info('[AVD OUTPUT] ' + line);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5['return']) {
                _iterator5['return']();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        });
        proc.on('exit', function (code, signal) {
          if (code !== 0) {
            throw new Error('Emulator avd ' + avdName + ' exit with code ' + code + ', signal ' + signal);
          }
        });
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retryTimes, this.getRunningAVDWithRetry.bind(this), avdName, avdLaunchTimeout));

      case 22:
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap(this.waitForEmulatorReady(avdReadyTimeout));

      case 24:
        return context$1$0.abrupt('return', proc);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * @typedef {Object} ADBVersion
 * @property {string} versionString - ADB version as a string.
 * @property {float} versionFloat - Version number as float value (useful for comparison).
 * @property {number} major - Major version number.
 * @property {number} minor - Minor version number.
 * @property {number} patch - Patch version number.
 */

/**
 * Get the adb version. The result of this method is cached.
 *
 * @return {ADBVersion} The current adb version.
 * @throws {Error} If it is not possible to parse adb version.
 */
systemCallMethods.getAdbVersion = _lodash2['default'].memoize(function callee$0$0() {
  var adbVersion, parts;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.adbExec('version'));

      case 3:
        adbVersion = context$1$0.sent.replace(/Android\sDebug\sBridge\sversion\s([\d\.]*)[\s\w\-]*/, "$1");
        parts = adbVersion.split('.');
        return context$1$0.abrupt('return', {
          versionString: adbVersion,
          versionFloat: parseFloat(adbVersion),
          major: parseInt(parts[0], 10),
          minor: parseInt(parts[1], 10),
          patch: parts[2] ? parseInt(parts[2], 10) : undefined
        });

      case 8:
        context$1$0.prev = 8;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Error getting adb version. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 8]]);
});

/**
 * Check if given emulator exists in the list of available avds.
 *
 * @param {string} avdName - The name of emulator to verify for existence.
 * @throws {Error} If the emulator with given name does not exist.
 */
systemCallMethods.checkAvdExist = function callee$0$0(avdName) {
  var cmd, result, unknownOptionError, sdkVersion, binaryName, existings;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = undefined, result = undefined;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath('emulator'));

      case 4:
        cmd = context$1$0.sent;
        context$1$0.next = 7;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['-list-avds']));

      case 7:
        result = context$1$0.sent;
        context$1$0.next = 26;
        break;

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](1);
        unknownOptionError = new RegExp("unknown option: -list-avds", "i").test(context$1$0.t0.stderr);

        if (unknownOptionError) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('Error executing checkAvdExist. Original error: \'' + context$1$0.t0.message + '\'; ' + ('Stderr: \'' + (context$1$0.t0.stderr || '').trim() + '\'; Code: \'' + context$1$0.t0.code + '\''));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap((0, _helpers.getSdkToolsVersion)());

      case 17:
        sdkVersion = context$1$0.sent;
        binaryName = 'android';

        if (sdkVersion) {
          if (sdkVersion.major >= 25) {
            binaryName = 'avdmanager';
          }
        } else {
          _loggerJs2['default'].warn('Defaulting binary name to \'' + binaryName + '\', because SDK version cannot be parsed');
        }
        // If -list-avds option is not available, use android command as an alternative
        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(this.getSdkBinaryPath(binaryName));

      case 22:
        cmd = context$1$0.sent;
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, ['list', 'avd', '-c']));

      case 25:
        result = context$1$0.sent;

      case 26:
        if (!(result.stdout.indexOf(avdName) === -1)) {
          context$1$0.next = 29;
          break;
        }

        existings = '(' + result.stdout.trim().replace(/[\n]/g, '), (') + ')';
        throw new Error('Avd \'' + avdName + '\' is not available. please select your avd name from one of these: \'' + existings + '\'');

      case 29:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[1, 10]]);
};

/**
 * Check if the current emulator is ready to accept further commands (booting completed).
 *
 * @param {number} timeoutMs [20000] - The maximum number of milliseconds to wait.
 * @throws {Error} If the emulator is not ready within the given timeout.
 */
systemCallMethods.waitForEmulatorReady = function callee$0$0() {
  var timeoutMs = arguments.length <= 0 || arguments[0] === undefined ? 20000 : arguments[0];
  var start, stdout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        start = Date.now();

        _loggerJs2['default'].debug("Waiting until emulator is ready");

      case 2:
        if (!(Date.now() - start < timeoutMs)) {
          context$1$0.next = 17;
          break;
        }

        context$1$0.prev = 3;
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(this.shell(["getprop", "init.svc.bootanim"]));

      case 6:
        stdout = context$1$0.sent;

        if (!(stdout.indexOf('stopped') > -1)) {
          context$1$0.next = 9;
          break;
        }

        return context$1$0.abrupt('return');

      case 9:
        context$1$0.next = 13;
        break;

      case 11:
        context$1$0.prev = 11;
        context$1$0.t0 = context$1$0['catch'](3);

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap((0, _asyncbox.sleep)(3000));

      case 15:
        context$1$0.next = 2;
        break;

      case 17:
        throw new Error('Emulator not ready');

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[3, 11]]);
};

/**
 * Check if the current device is ready to accept further commands (booting completed).
 *
 * @param {number} appDeviceReadyTimeout [30] - The maximum number of seconds to wait.
 * @throws {Error} If the device is not ready within the given timeout.
 */
systemCallMethods.waitForDevice = function callee$0$0() {
  var appDeviceReadyTimeout = arguments.length <= 0 || arguments[0] === undefined ? 30 : arguments[0];
  var retries, timeout;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this3 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        this.appDeviceReadyTimeout = appDeviceReadyTimeout;
        retries = 3;
        timeout = parseInt(this.appDeviceReadyTimeout, 10) / retries * 1000;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap((0, _asyncbox.retry)(retries, function callee$1$0() {
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.prev = 0;
                context$2$0.next = 3;
                return _regeneratorRuntime.awrap(this.adbExec('wait-for-device', { timeout: timeout }));

              case 3:
                context$2$0.next = 5;
                return _regeneratorRuntime.awrap(this.ping());

              case 5:
                context$2$0.next = 14;
                break;

              case 7:
                context$2$0.prev = 7;
                context$2$0.t0 = context$2$0['catch'](0);
                context$2$0.next = 11;
                return _regeneratorRuntime.awrap(this.restartAdb());

              case 11:
                context$2$0.next = 13;
                return _regeneratorRuntime.awrap(this.getConnectedDevices());

              case 13:
                throw new Error('Error in waiting for device. Original error: \'' + context$2$0.t0.message + '\'. ' + 'Retrying by restarting ADB');

              case 14:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this3, [[0, 7]]);
        }));

      case 5:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Reboot the current device and wait until it is completed.
 *
 * @param {number} retries [DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.
 * @throws {Error} If the device failed to reboot and number of retries is exceeded.
 */
systemCallMethods.reboot = function callee$0$0() {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_ADB_REBOOT_RETRIES : arguments[0];
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this4 = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.prev = 1;
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 4:
        context$1$0.next = 15;
        break;

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](1);

        if (!(context$1$0.t0.message.indexOf('must be root') === -1)) {
          context$1$0.next = 10;
          break;
        }

        throw context$1$0.t0;

      case 10:
        // this device needs adb to be running as root to stop.
        // so try to restart the daemon
        _loggerJs2['default'].debug('Device requires adb to be running as root in order to reboot. Restarting daemon');
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(this.root());

      case 13:
        context$1$0.next = 15;
        return _regeneratorRuntime.awrap(this.shell(['stop']));

      case 15:
        context$1$0.next = 17;
        return _regeneratorRuntime.awrap(_bluebird2['default'].delay(2000));

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(this.setDeviceProperty('sys.boot_completed', 0));

      case 19:
        context$1$0.next = 21;
        return _regeneratorRuntime.awrap(this.shell(['start']));

      case 21:
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap((0, _asyncbox.retryInterval)(retries, 1000, function callee$1$0() {
          var booted, msg;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                context$2$0.next = 2;
                return _regeneratorRuntime.awrap(this.getDeviceProperty('sys.boot_completed'));

              case 2:
                booted = context$2$0.sent;

                if (!(booted === '1')) {
                  context$2$0.next = 7;
                  break;
                }

                return context$2$0.abrupt('return');

              case 7:
                msg = 'Waiting for reboot. This takes time';

                _loggerJs2['default'].debug(msg);
                throw new Error(msg);

              case 10:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this4);
        }));

      case 23:
        context$1$0.prev = 23;
        context$1$0.next = 26;
        return _regeneratorRuntime.awrap(this.unroot());

      case 26:
        return context$1$0.finish(23);

      case 27:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0,, 23, 27], [1, 6]]);
};

/**
 * Switch adb server to root mode.
 *
 * @return {boolean} True of the switch was successful or false
 *                   if the switch failed.
 */
systemCallMethods.root = function callee$0$0() {
  var _ref4, stdout;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['root']));

      case 3:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;

        if (!(stdout && stdout.indexOf('adbd cannot run as root') !== -1)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error(stdout.trim());

      case 7:
        return context$1$0.abrupt('return', true);

      case 10:
        context$1$0.prev = 10;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to root adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 10]]);
};

/**
 * Switch adb server to non-root mode.
 *
 * @return {boolean} True of the switch was successful or false
 *                   if the switch failed.
 */
systemCallMethods.unroot = function callee$0$0() {
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(this.executable.path, ['unroot']));

      case 3:
        return context$1$0.abrupt('return', true);

      case 6:
        context$1$0.prev = 6;
        context$1$0.t0 = context$1$0['catch'](0);

        _loggerJs2['default'].warn('Unable to unroot adb daemon: \'' + context$1$0.t0.message + '\'. Continuing');
        return context$1$0.abrupt('return', false);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 6]]);
};

/**
 * Verify whether a remote path exists on the device under test.
 *
 * @param {string} remotePath - The remote path to verify.
 * @return {boolean} True if the given path exists on the device.
 */
systemCallMethods.fileExists = function callee$0$0(remotePath) {
  var files;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(this.ls(remotePath));

      case 2:
        files = context$1$0.sent;
        return context$1$0.abrupt('return', files.length > 0);

      case 4:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
};

/**
 * Get the output of _ls_ command on the device under test.
 *
 * @param {string} remotePath - The remote path (the first argument to the _ls_ command).
 * @param {Array.<String>} opts [[]] - Additional _ls_ options.
 * @return {Array.<String>} The _ls_ output as an array of split lines.
 *                          An empty array is returned of the given _remotePath_
 *                          does not exist.
 */
systemCallMethods.ls = function callee$0$0(remotePath) {
  var opts = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
  var args, stdout, lines;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        args = ['ls'].concat(_toConsumableArray(opts), [remotePath]);
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap(this.shell(args));

      case 4:
        stdout = context$1$0.sent;
        lines = stdout.split("\n");
        return context$1$0.abrupt('return', lines.map(function (l) {
          return l.trim();
        }).filter(Boolean).filter(function (l) {
          return l.indexOf("No such file") === -1;
        }));

      case 9:
        context$1$0.prev = 9;
        context$1$0.t0 = context$1$0['catch'](0);

        if (!(context$1$0.t0.message.indexOf('No such file or directory') === -1)) {
          context$1$0.next = 13;
          break;
        }

        throw context$1$0.t0;

      case 13:
        return context$1$0.abrupt('return', []);

      case 14:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 9]]);
};

/**
 * Get the size of the particular file located on the device under test.
 *
 * @param {string} remotePath - The remote path to the file.
 * @return {number} File size in bytes.
 * @throws {Error} If there was an error while getting the size of the given file.
 */
systemCallMethods.fileSize = function callee$0$0(remotePath) {
  var files, match;
  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.prev = 0;
        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(this.ls(remotePath, ['-la']));

      case 3:
        files = context$1$0.sent;

        if (!(files.length !== 1)) {
          context$1$0.next = 6;
          break;
        }

        throw new Error('Remote path is not a file');

      case 6:
        match = /\s(\d+)\s+\d{4}-\d{2}-\d{2}/.exec(files[0]);

        if (!(!match || _lodash2['default'].isNaN(parseInt(match[1], 10)))) {
          context$1$0.next = 9;
          break;
        }

        throw new Error('Unable to parse size from list output: \'' + files[0] + '\'');

      case 9:
        return context$1$0.abrupt('return', parseInt(match[1], 10));

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](0);
        throw new Error('Unable to get file size for \'' + remotePath + '\': ' + context$1$0.t0.message);

      case 15:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[0, 12]]);
};

/**
 * Installs the given certificate on a rooted real device or
 * an emulator. The emulator must be executed with `-writable-system`
 * command line option and adb daemon should be running in root
 * mode for this method to work properly. The method also requires
 * openssl tool to be available on the destination system.
 * Read https://github.com/appium/appium/issues/10964
 * for more details on this topic
 *
 * @param {Buffer|string} cert - base64-decoded content of the actual certificate
 * represented as a string or a buffer
 * @throws {Error} If openssl tool is not available on the destination system
 * or if there was an error while installing the certificate
 */
systemCallMethods.installMitmCertificate = function callee$0$0(cert) {
  var openSsl, tempCert, _ref5, stdout, certHash, _ref6, dstCertContent, _ref7, dstCert;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _helpers.getOpenSslForOs)());

      case 2:
        openSsl = context$1$0.sent;

        if (!_lodash2['default'].isBuffer(cert)) {
          cert = Buffer.from(cert, 'base64');
        }

        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.open({
          prefix: 'cert',
          suffix: '.cer'
        }));

      case 6:
        tempCert = context$1$0.sent;
        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempCert.path, cert));

      case 10:
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tempCert.path]));

      case 12:
        _ref5 = context$1$0.sent;
        stdout = _ref5.stdout;
        certHash = stdout.trim();

        _loggerJs2['default'].debug('Got certificate hash: ' + certHash);
        _loggerJs2['default'].debug('Preparing certificate content');
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-in', tempCert.path], { isBuffer: true }));

      case 19:
        _ref6 = context$1$0.sent;
        stdout = _ref6.stdout;
        dstCertContent = stdout;
        context$1$0.next = 24;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-in', tempCert.path, '-text', '-fingerprint', '-noout'], { isBuffer: true }));

      case 24:
        _ref7 = context$1$0.sent;
        stdout = _ref7.stdout;

        dstCertContent = dstCertContent.concat(stdout);
        context$1$0.next = 29;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.open({
          prefix: certHash,
          suffix: '.0'
        }));

      case 29:
        dstCert = context$1$0.sent;
        context$1$0.prev = 30;
        context$1$0.next = 33;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(dstCert.path, dstCertContent));

      case 33:
        _loggerJs2['default'].debug('Mounting /system endpoint');
        context$1$0.next = 36;
        return _regeneratorRuntime.awrap(this.shell(['mount', '-o', 'rw,remount', '/system']));

      case 36:
        _loggerJs2['default'].debug('Uploading the generated certificate from \'' + dstCert.path + '\' to \'' + CERTS_ROOT + '\'');
        context$1$0.next = 39;
        return _regeneratorRuntime.awrap(this.push(dstCert.path, CERTS_ROOT));

      case 39:
        _loggerJs2['default'].debug('Remounting the remote file system');
        context$1$0.next = 42;
        return _regeneratorRuntime.awrap(this.adbExec(['remount']));

      case 42:
        context$1$0.prev = 42;
        context$1$0.next = 45;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.close(dstCert.fd));

      case 45:
        context$1$0.next = 47;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(dstCert.path));

      case 47:
        return context$1$0.finish(42);

      case 48:
        context$1$0.next = 53;
        break;

      case 50:
        context$1$0.prev = 50;
        context$1$0.t0 = context$1$0['catch'](7);
        throw new Error('Cannot inject the custom certificate. ' + 'Is the certificate properly encoded into base64-string? ' + 'Do you have root permissions on the device? ' + ('Original error: ' + context$1$0.t0.message));

      case 53:
        context$1$0.prev = 53;
        context$1$0.next = 56;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.close(tempCert.fd));

      case 56:
        context$1$0.next = 58;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(tempCert.path));

      case 58:
        return context$1$0.finish(53);

      case 59:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 50, 53, 59], [30,, 42, 48]]);
};

/**
 * Verifies if the given root certificate is already installed on the device.
 *
 * @param {Buffer|string} cert - base64-decoded content of the actual certificate
 * represented as a string or a buffer
 * @throws {Error} If openssl tool is not available on the destination system
 * or if there was an error while checking the certificate
 * @returns {boolean} true if the given certificate is already installed
 */
systemCallMethods.isMitmCertificateInstalled = function callee$0$0(cert) {
  var openSsl, tempCert, certHash, _ref8, stdout, dstPath;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _helpers.getOpenSslForOs)());

      case 2:
        openSsl = context$1$0.sent;
        context$1$0.next = 5;
        return _regeneratorRuntime.awrap(_appiumSupport.tempDir.open({
          prefix: 'cert',
          suffix: '.cer'
        }));

      case 5:
        tempCert = context$1$0.sent;
        certHash = undefined;
        context$1$0.prev = 7;
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(tempCert.path, cert));

      case 10:
        context$1$0.next = 12;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(openSsl, ['x509', '-noout', '-hash', '-in', tempCert.path]));

      case 12:
        _ref8 = context$1$0.sent;
        stdout = _ref8.stdout;

        certHash = stdout.trim();
        context$1$0.next = 20;
        break;

      case 17:
        context$1$0.prev = 17;
        context$1$0.t0 = context$1$0['catch'](7);
        throw new Error('Cannot retrieve the certificate hash. ' + 'Is the certificate properly encoded into base64-string? ' + ('Original error: ' + context$1$0.t0.message));

      case 20:
        context$1$0.prev = 20;
        context$1$0.next = 23;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.close(tempCert.fd));

      case 23:
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.rimraf(tempCert.path));

      case 25:
        return context$1$0.finish(20);

      case 26:
        dstPath = _path2['default'].posix.resolve(CERTS_ROOT, certHash + '.0');

        _loggerJs2['default'].debug('Checking if the certificate is already installed at \'' + dstPath + '\'');
        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(this.fileExists(dstPath));

      case 30:
        return context$1$0.abrupt('return', context$1$0.sent);

      case 31:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[7, 17, 20, 26]]);
};

exports['default'] = systemCallMethods;
module.exports = exports['default'];

// get subpaths for currently installed build tool directories

// expecting adb devices to return output as
// List of devices attached
// emulator-5554	device

// cool down

// cool down

// The methods is used to remove telnet auth token
//

// cool down

// do nothing
// let the emu finish stopping;

// we don't want the stack trace, so no log.errorAndThrow

// on real devices in some situations we get an error in the stdout

// https://regex101.com/r/fOs4P4/3
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi90b29scy9zeXN0ZW0tY2FsbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCLE1BQU07Ozs7d0JBQ1AsY0FBYzs7Ozt3QkFDaEIsVUFBVTs7Ozs2QkFDa0IsZ0JBQWdCOzt1QkFFakMsWUFBWTs7NEJBQ0osY0FBYzs7d0JBQ0gsVUFBVTs7c0JBQ3hDLFFBQVE7Ozs7MEJBQ0EsYUFBYTs7QUFHbkMsSUFBSSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7O0FBRTNCLElBQU0sd0JBQXdCLEdBQUcsS0FBSyxDQUFDO0FBQ3ZDLElBQU0sMEJBQTBCLEdBQUcsRUFBRSxDQUFDOztBQUV0QyxJQUFNLHFCQUFxQixHQUFHLHNCQUFzQixDQUFDO0FBQ3JELElBQU0sMkJBQTJCLEdBQUcsSUFBSSxNQUFNLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdEYsSUFBTSw2QkFBNkIsR0FBRyxJQUFJLE1BQU0sc0NBQW9DLEdBQUcsQ0FBQyxDQUFDO0FBQ3pGLElBQU0sOEJBQThCLEdBQUcsSUFBSSxNQUFNLENBQUMsZ0NBQWdDLEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRXpGLElBQU0sVUFBVSxHQUFHLDhCQUE4QixDQUFDOzs7Ozs7OztBQVFsRCxpQkFBaUIsQ0FBQyxnQkFBZ0IsR0FBRyxvQkFBRSxPQUFPLENBQUMsb0JBQWdCLFVBQVU7Ozs7QUFDdkUsOEJBQUksSUFBSSx1QkFBcUIsVUFBVSxpQkFBYyxDQUFDOzthQUNsRCxJQUFJLENBQUMsT0FBTzs7Ozs7O3lDQUNELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxVQUFVLENBQUM7Ozs7OztBQUVwRCw4QkFBSSxJQUFJLENBQUMsMklBQ2tFLCtDQUN6QixVQUFVLE9BQUcsQ0FBQyxDQUFDOzt5Q0FDcEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQzs7Ozs7Ozs7OztDQUNoRCxDQUFDLENBQUM7Ozs7Ozs7OztBQVNILGlCQUFpQixDQUFDLGVBQWUsR0FB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QUcsb0JBQWdCLElBQUk7TUFDM0QsT0FBTyxFQUNQLFFBQVEsRUFJVixRQUFRLFNBR0wsTUFBTSxFQVVQLE9BQU87Ozs7Ozt5Q0FsQlMsK0JBQWlCOzs7QUFBakMsZUFBTzs7eUNBQ1UsdUJBQVEsSUFBSSxDQUFDO0FBQ2xDLGdCQUFNLEVBQUUsTUFBTTtBQUNkLGdCQUFNLEVBQUUsTUFBTTtTQUNmLENBQUM7OztBQUhJLGdCQUFRO0FBSVYsZ0JBQVE7Ozt5Q0FFSixrQkFBRyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUM7Ozs7eUNBQ2xCLHdCQUFLLE9BQU8sRUFBRSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7QUFBaEYsY0FBTSxTQUFOLE1BQU07O0FBQ1gsZ0JBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7Ozs7Ozs7Y0FFbkIsSUFBSSxLQUFLLENBQUMscUdBQzBELHlCQUN2QyxlQUFJLE9BQU8sQ0FBRSxDQUFDOzs7Ozt5Q0FFM0Msa0JBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7Ozs7eUNBQ3JCLGtCQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDOzs7Ozs7QUFFMUIsZUFBTyxHQUFHLGtCQUFLLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFLLFFBQVEsUUFBSzs7QUFDL0QsOEJBQUksS0FBSyw0REFBeUQsT0FBTyxRQUFJLENBQUM7O3lDQUNqRSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQzs7Ozs7Ozs7OztDQUN0QyxDQUFDOztxQkFFYSxpQkFBaUIiLCJmaWxlIjoibGliL3Rvb2xzL3N5c3RlbS1jYWxscy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXIuanMnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc3lzdGVtLCBmcywgdXRpbCwgdGVtcERpciB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCB7IGdldFNka1Rvb2xzVmVyc2lvbiwgZ2V0QnVpbGRUb29sc0RpcnMsXG4gIGdldE9wZW5Tc2xGb3JPcyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgZXhlYywgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBzbGVlcCwgcmV0cnksIHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgcXVvdGUgfSBmcm9tICdzaGVsbC1xdW90ZSc7XG5cblxubGV0IHN5c3RlbUNhbGxNZXRob2RzID0ge307XG5cbmNvbnN0IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVCA9IDIwMDAwOyAvLyBpbiBtaWxsaXNlY29uZHNcbmNvbnN0IERFRkFVTFRfQURCX1JFQk9PVF9SRVRSSUVTID0gOTA7XG5cbmNvbnN0IExJTktFUl9XQVJOSU5HX1JFR0VYUCA9IC9eV0FSTklORzogbGlua2VyLiskL207XG5jb25zdCBQUk9UT0NPTF9GQVVMVF9FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdwcm90b2NvbCBmYXVsdCBcXFxcKG5vIHN0YXR1c1xcXFwpJywgJ2knKTtcbmNvbnN0IERFVklDRV9OT1RfRk9VTkRfRVJST1JfUkVHRVhQID0gbmV3IFJlZ0V4cChgZXJyb3I6IGRldmljZSAoJy4rJyApP25vdCBmb3VuZGAsICdpJyk7XG5jb25zdCBERVZJQ0VfQ09OTkVDVElOR19FUlJPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCdlcnJvcjogZGV2aWNlIHN0aWxsIGNvbm5lY3RpbmcnLCAnaScpO1xuXG5jb25zdCBDRVJUU19ST09UID0gJy9zeXN0ZW0vZXRjL3NlY3VyaXR5L2NhY2VydHMnO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGJpbmFyeS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkgaW5jbHVkaW5nIGN1cnJlbnQgU0RLIHJvb3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFNka0JpbmFyeVBhdGggPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gKGJpbmFyeU5hbWUpIHtcbiAgbG9nLmluZm8oYENoZWNraW5nIHdoZXRoZXIgJHtiaW5hcnlOYW1lfSBpcyBwcmVzZW50YCk7XG4gIGlmICh0aGlzLnNka1Jvb3QpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRCaW5hcnlGcm9tU2RrUm9vdChiaW5hcnlOYW1lKTtcbiAgfVxuICBsb2cud2FybihgVGhlIEFORFJPSURfSE9NRSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3Qgc2V0IHRvIHRoZSBBbmRyb2lkIFNESyBgICtcbiAgICAgICAgICAgYHJvb3QgZGlyZWN0b3J5IHBhdGguIEFORFJPSURfSE9NRSBpcyByZXF1aXJlZCBmb3IgY29tcGF0aWJpbGl0eSBgICtcbiAgICAgICAgICAgYHdpdGggU0RLIDIzKy4gQ2hlY2tpbmcgYWxvbmcgUEFUSCBmb3IgJHtiaW5hcnlOYW1lfS5gKTtcbiAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmluYXJ5RnJvbVBhdGgoYmluYXJ5TmFtZSk7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbmFtZSBvZiB0aGUgdG9vbCxcbiAqIHdoaWNoIHByaW50cyBmdWxsIHBhdGggdG8gdGhlIGdpdmVuIGNvbW1hbmQgc2hvcnRjdXQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBEZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgcGxhdGZvcm0gdGhpcyBpc1xuICogICAgICAgICAgICAgICAgICBzdXBwb3NlZCB0byBiZSBlaXRoZXIgJ3doaWNoJyBvciAnd2hlcmUnLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb21tYW5kRm9yT1MgPSBfLm1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc3lzdGVtLmlzV2luZG93cygpID8gJ3doZXJlJyA6ICd3aGljaCc7XG59KTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBmdWxsIGJpbmFyeSBuYW1lIGZvciB0aGUgY3VycmVudCBvcGVyYXRpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gc2ltcGxlIGJpbmFyeSBuYW1lLCBmb3IgZXhhbXBsZSAnYW5kcm9pZCcuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEZvcm1hdHRlZCBiaW5hcnkgbmFtZSBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgcGxhdGZvcm0sXG4gKiAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCAnYW5kcm9pZC5iYXQnIG9uIFdpbmRvd3MuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeU5hbWVGb3JPUyA9IF8ubWVtb2l6ZShmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBpZiAoIXN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIHJldHVybiBiaW5hcnlOYW1lO1xuICB9XG5cbiAgaWYgKFsnYW5kcm9pZCcsICdhcGtzaWduZXInLCAnYXBrYW5hbHl6ZXInXS5pbmRleE9mKGJpbmFyeU5hbWUpID49IDAgJiZcbiAgICAgICFiaW5hcnlOYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5iYXQnKSkge1xuICAgIHJldHVybiBgJHtiaW5hcnlOYW1lfS5iYXRgO1xuICB9XG4gIGlmICghYmluYXJ5TmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKCcuZXhlJykpIHtcbiAgICByZXR1cm4gYCR7YmluYXJ5TmFtZX0uZXhlYDtcbiAgfVxuICByZXR1cm4gYmluYXJ5TmFtZTtcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byB0aGUgZ2l2ZW4gYmluYXJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiaW5hcnlOYW1lIC0gU2ltcGxlIG5hbWUgb2YgYSBiaW5hcnkgZmlsZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gRnVsbCBwYXRoIHRvIHRoZSBnaXZlbiBiaW5hcnkuIFRoZSBtZXRob2QgdHJpZXNcbiAqICAgICAgICAgICAgICAgICAgdG8gZW51bWVyYXRlIGFsbCB0aGUga25vd24gbG9jYXRpb25zIHdoZXJlIHRoZSBiaW5hcnlcbiAqICAgICAgICAgICAgICAgICAgbWlnaHQgYmUgbG9jYXRlZCBhbmQgc3RvcHMgdGhlIHNlYXJjaCBhcyBzb29uIGFzIHRoZSBmaXJzdFxuICogICAgICAgICAgICAgICAgICBtYXRjaCBpcyBmb3VuZCBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGJpbmFyeSB3aXRoIGdpdmVuIG5hbWUgaXMgbm90IHByZXNlbnQgYXQgYW55XG4gKiAgICAgICAgICAgICAgICAgb2Yga25vd24gbG9jYXRpb25zIG9yIEFuZHJvaWQgU0RLIGlzIG5vdCBpbnN0YWxsZWQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgbG9jYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEJpbmFyeUZyb21TZGtSb290ID0gXy5tZW1vaXplKGFzeW5jIGZ1bmN0aW9uIChiaW5hcnlOYW1lKSB7XG4gIGxldCBiaW5hcnlMb2MgPSBudWxsO1xuICBiaW5hcnlOYW1lID0gdGhpcy5nZXRCaW5hcnlOYW1lRm9yT1MoYmluYXJ5TmFtZSk7XG4gIGxldCBiaW5hcnlMb2NzID0gW1xuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwicGxhdGZvcm0tdG9vbHNcIiwgYmluYXJ5TmFtZSksXG4gICAgcGF0aC5yZXNvbHZlKHRoaXMuc2RrUm9vdCwgXCJlbXVsYXRvclwiLCBiaW5hcnlOYW1lKSxcbiAgICBwYXRoLnJlc29sdmUodGhpcy5zZGtSb290LCBcInRvb2xzXCIsIGJpbmFyeU5hbWUpLFxuICAgIHBhdGgucmVzb2x2ZSh0aGlzLnNka1Jvb3QsIFwidG9vbHNcIiwgXCJiaW5cIiwgYmluYXJ5TmFtZSlcbiAgXTtcbiAgLy8gZ2V0IHN1YnBhdGhzIGZvciBjdXJyZW50bHkgaW5zdGFsbGVkIGJ1aWxkIHRvb2wgZGlyZWN0b3JpZXNcbiAgXy5mb3JFYWNoKGF3YWl0IGdldEJ1aWxkVG9vbHNEaXJzKHRoaXMuc2RrUm9vdCksXG4gICAgICAgICAgICAoZGlyKSA9PiBiaW5hcnlMb2NzLnB1c2gocGF0aC5yZXNvbHZlKGRpciwgYmluYXJ5TmFtZSkpKTtcbiAgZm9yIChsZXQgbG9jIG9mIGJpbmFyeUxvY3MpIHtcbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGxvYykpIHtcbiAgICAgIGJpbmFyeUxvYyA9IGxvYztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoXy5pc051bGwoYmluYXJ5TG9jKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgJHtiaW5hcnlOYW1lfSBpbiAke2JpbmFyeUxvY3N9LiBgICtcbiAgICAgICAgICAgICAgICAgICAgYERvIHlvdSBoYXZlIHRoZSBBbmRyb2lkIFNESyBpbnN0YWxsZWQgYXQgJyR7dGhpcy5zZGtSb290fSc/YCk7XG4gIH1cbiAgYmluYXJ5TG9jID0gYmluYXJ5TG9jLnRyaW0oKTtcbiAgbG9nLmluZm8oYFVzaW5nICR7YmluYXJ5TmFtZX0gZnJvbSAke2JpbmFyeUxvY31gKTtcbiAgcmV0dXJuIGJpbmFyeUxvYztcbn0pO1xuXG4vKipcbiAqIFJldHJpZXZlIGZ1bGwgcGF0aCB0byBhIGJpbmFyeSBmaWxlIHVzaW5nIHRoZSBzdGFuZGFyZCBzeXN0ZW0gbG9va3VwIHRvb2wuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYmluYXJ5LlxuICogQHJldHVybiB7c3RyaW5nfSBGdWxsIHBhdGggdG8gdGhlIGJpbmFyeSByZWNlaXZlZCBmcm9tICd3aGljaCcvJ3doZXJlJ1xuICogICAgICAgICAgICAgICAgICBvdXRwdXQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgbG9va3VwIHRvb2wgcmV0dXJucyBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0QmluYXJ5RnJvbVBhdGggPSBhc3luYyBmdW5jdGlvbiAoYmluYXJ5TmFtZSkge1xuICBsZXQgYmluYXJ5TG9jID0gbnVsbDtcbiAgbGV0IGNtZCA9IHRoaXMuZ2V0Q29tbWFuZEZvck9TKCk7XG4gIHRyeSB7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIFtiaW5hcnlOYW1lXSk7XG4gICAgbG9nLmluZm8oYFVzaW5nICR7YmluYXJ5TmFtZX0gZnJvbSAke3N0ZG91dH1gKTtcbiAgICAvLyBUT0RPIHdyaXRlIGEgdGVzdCBmb3IgYmluYXJpZXMgd2l0aCBzcGFjZXMuXG4gICAgYmluYXJ5TG9jID0gc3Rkb3V0LnRyaW0oKTtcbiAgICByZXR1cm4gYmluYXJ5TG9jO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2JpbmFyeU5hbWV9IFBsZWFzZSBzZXQgdGhlIEFORFJPSURfSE9NRSBgICtcbiAgICAgICAgICAgICAgYGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggdGhlIEFuZHJvaWQgU0RLIHJvb3QgZGlyZWN0b3J5IHBhdGguYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRGV2aWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdWRpZCAtIFRoZSBkZXZpY2UgdWRpZC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZSAtIEN1cnJlbnQgZGV2aWNlIHN0YXRlLCBhcyBpdCBpcyB2aXNpYmxlIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYWRiIGRldmljZXMgLWxfIG91dHB1dC5cbiAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBsaXN0IG9mIGRldmljZXMgdmlzaWJsZSB0byBhZGIuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGRldmljZXMgb3IgYW4gZW1wdHkgbGlzdCBpZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIG5vIGRldmljZXMgYXJlIGNvbm5lY3RlZC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbGlzdGluZyBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRDb25uZWN0ZWREZXZpY2VzID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBsb2cuZGVidWcoXCJHZXR0aW5nIGNvbm5lY3RlZCBkZXZpY2VzLi4uXCIpO1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoWydkZXZpY2VzJ10pKTtcbiAgICAvLyBleHBlY3RpbmcgYWRiIGRldmljZXMgdG8gcmV0dXJuIG91dHB1dCBhc1xuICAgIC8vIExpc3Qgb2YgZGV2aWNlcyBhdHRhY2hlZFxuICAgIC8vIGVtdWxhdG9yLTU1NTRcdGRldmljZVxuICAgIGxldCBzdGFydGluZ0luZGV4ID0gc3Rkb3V0LmluZGV4T2YoXCJMaXN0IG9mIGRldmljZXNcIik7XG4gICAgaWYgKHN0YXJ0aW5nSW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3V0cHV0IHdoaWxlIHRyeWluZyB0byBnZXQgZGV2aWNlcy4gb3V0cHV0IHdhczogJHtzdGRvdXR9YCk7XG4gICAgfVxuICAgIC8vIHNsaWNpbmcgb3VwdXQgd2UgY2FyZSBhYm91dC5cbiAgICBzdGRvdXQgPSBzdGRvdXQuc2xpY2Uoc3RhcnRpbmdJbmRleCk7XG4gICAgbGV0IGRldmljZXMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHN0ZG91dC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgaWYgKGxpbmUudHJpbSgpICE9PSBcIlwiICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKFwiTGlzdCBvZiBkZXZpY2VzXCIpID09PSAtMSAmJlxuICAgICAgICAgIGxpbmUuaW5kZXhPZihcImFkYiBzZXJ2ZXJcIikgPT09IC0xICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKFwiKiBkYWVtb25cIikgPT09IC0xICYmXG4gICAgICAgICAgbGluZS5pbmRleE9mKFwib2ZmbGluZVwiKSA9PT0gLTEpIHtcbiAgICAgICAgbGV0IGxpbmVJbmZvID0gbGluZS5zcGxpdChcIlxcdFwiKTtcbiAgICAgICAgLy8gc3RhdGUgaXMgZWl0aGVyIFwiZGV2aWNlXCIgb3IgXCJvZmZsaW5lXCIsIGFmYWljdFxuICAgICAgICBkZXZpY2VzLnB1c2goe3VkaWQ6IGxpbmVJbmZvWzBdLCBzdGF0ZTogbGluZUluZm9bMV19KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGAke2RldmljZXMubGVuZ3RofSBkZXZpY2UocykgY29ubmVjdGVkYCk7XG4gICAgcmV0dXJuIGRldmljZXM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIHdoaWxlIGdldHRpbmcgY29ubmVjdGVkIGRldmljZXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBkZXZpY2VzIHZpc2libGUgdG8gYWRiIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBnZXQgYXQgbGVhc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUgbGlzdCBpdGVtLlxuICogQHJldHVybiB7QXJyYXkuPERldmljZT59IFRoZSBsaXN0IG9mIGNvbm5lY3RlZCBkZXZpY2VzLlxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIGNvbm5lY3RlZCBkZXZpY2VzIGNhbiBiZSBkZXRlY3RlZCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldERldmljZXNXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiAodGltZW91dE1zID0gMjAwMDApIHtcbiAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgbG9nLmRlYnVnKFwiVHJ5aW5nIHRvIGZpbmQgYSBjb25uZWN0ZWQgYW5kcm9pZCBkZXZpY2VcIik7XG4gIGxldCBnZXREZXZpY2VzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA+IHRpbWVvdXRNcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYSBjb25uZWN0ZWQgQW5kcm9pZCBkZXZpY2UuXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICAgIGlmIChkZXZpY2VzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgbG9nLmRlYnVnKFwiQ291bGQgbm90IGZpbmQgZGV2aWNlcywgcmVzdGFydGluZyBhZGIgc2VydmVyLi4uXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgICAgLy8gY29vbCBkb3duXG4gICAgICAgIGF3YWl0IHNsZWVwKDIwMCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGV2aWNlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2cuZGVidWcoXCJDb3VsZCBub3QgZmluZCBkZXZpY2VzLCByZXN0YXJ0aW5nIGFkYiBzZXJ2ZXIuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLnJlc3RhcnRBZGIoKTtcbiAgICAgIC8vIGNvb2wgZG93blxuICAgICAgYXdhaXQgc2xlZXAoMjAwKTtcbiAgICAgIHJldHVybiBhd2FpdCBnZXREZXZpY2VzKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gYXdhaXQgZ2V0RGV2aWNlcygpO1xufTtcblxuLyoqXG4gKiBSZXN0YXJ0IGFkYiBzZXJ2ZXIgaWYgX3RoaXMuc3VwcHJlc3NLaWxsU2VydmVyXyBwcm9wZXJ0eSBpcyB0cnVlLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXN0YXJ0QWRiID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdXBwcmVzc0tpbGxTZXJ2ZXIpIHtcbiAgICBsb2cuZGVidWcoYE5vdCByZXN0YXJ0aW5nIGFiZCBzaW5jZSAnc3VwcHJlc3NLaWxsU2VydmVyJyBpcyBvbmApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZy5kZWJ1ZygnUmVzdGFydGluZyBhZGInKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmtpbGxTZXJ2ZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihcIkVycm9yIGtpbGxpbmcgQURCIHNlcnZlciwgZ29pbmcgdG8gc2VlIGlmIGl0J3Mgb25saW5lIGFueXdheVwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIGFkYiBzZXJ2ZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmtpbGxTZXJ2ZXIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhgS2lsbGluZyBhZGIgc2VydmVyIG9uIHBvcnQgJHt0aGlzLmFkYlBvcnR9YCk7XG4gIGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsuLi50aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MsICdraWxsLXNlcnZlciddKTtcbn07XG5cbi8qKlxuICogUmVzZXQgVGVsbmV0IGF1dGhlbnRpY2F0aW9uIHRva2VuLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmFuZHJvaWQuY29tL3JlY2VudC9lbXVsYXRvcjI1MTZyZWxlYXNlbm90ZXN9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IElmIHRva2VuIHJlc2V0IHdhcyBzdWNjZXNzZnVsLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yZXNldFRlbG5ldEF1dGhUb2tlbiA9IF8ubWVtb2l6ZShhc3luYyBmdW5jdGlvbiAoKSB7XG4gIC8vIFRoZSBtZXRob2RzIGlzIHVzZWQgdG8gcmVtb3ZlIHRlbG5ldCBhdXRoIHRva2VuXG4gIC8vXG4gIGNvbnN0IGhvbWVGb2xkZXJQYXRoID0gcHJvY2Vzcy5lbnZbKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpID8gJ1VTRVJQUk9GSUxFJyA6ICdIT01FJ107XG4gIGlmICghaG9tZUZvbGRlclBhdGgpIHtcbiAgICBsb2cud2FybignQ2Fubm90IGZpbmQgdGhlIHBhdGggdG8gdXNlciBob21lIGZvbGRlci4gSWdub3JpbmcgcmVzZXR0aW5nIG9mIGVtdWxhdG9yXFwncyB0ZWxuZXQgYXV0aGVudGljYXRpb24gdG9rZW4nKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShob21lRm9sZGVyUGF0aCwgJy5lbXVsYXRvcl9jb25zb2xlX2F1dGhfdG9rZW4nKTtcbiAgbG9nLmRlYnVnKGBPdmVycmlkaW5nICR7ZHN0UGF0aH0gd2l0aCBhbiBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgdGVsbmV0IGF1dGhlbnRpY2F0aW9uIGZvciBlbXVsYXRvciBjb21tYW5kc2ApO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2cud2FybihgRXJyb3IgJHtlLm1lc3NhZ2V9IHdoaWxlIHJlc2V0dGluZyB0aGUgY29udGVudCBvZiAke2RzdFBhdGh9LiBJZ25vcmluZyByZXNldHRpbmcgb2YgZW11bGF0b3JcXCdzIHRlbG5ldCBhdXRoZW50aWNhdGlvbiB0b2tlbmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGVtdWxhdG9yIGNvbW1hbmQgdXNpbmcgX2FkYiBlbXVfIHRvb2wuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWNFbXUgPSBhc3luYyBmdW5jdGlvbiAoY21kKSB7XG4gIGF3YWl0IHRoaXMudmVyaWZ5RW11bGF0b3JDb25uZWN0ZWQoKTtcbiAgYXdhaXQgdGhpcy5yZXNldFRlbG5ldEF1dGhUb2tlbigpO1xuICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydlbXUnLCAuLi5jbWRdKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSB0aGUgZ2l2ZW4gYWRiIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY21kIC0gVGhlIGFycmF5IG9mIHJlc3QgY29tbWFuZCBsaW5lIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICAgICAgICAgICAgIG9yIGEgc2luZ2xlIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmFkYkV4ZWMgPSBhc3luYyBmdW5jdGlvbiAoY21kLCBvcHRzID0ge30pIHtcbiAgaWYgKCFjbWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbmVlZCB0byBwYXNzIGluIGEgY29tbWFuZCB0byBhZGJFeGVjKClcIik7XG4gIH1cbiAgLy8gc2V0dGluZyBkZWZhdWx0IHRpbWVvdXQgZm9yIGVhY2ggY29tbWFuZCB0byBwcmV2ZW50IGluZmluaXRlIHdhaXQuXG4gIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCB0aGlzLmV4ZWNUaW1lb3V0IHx8IERFRkFVTFRfQURCX0VYRUNfVElNRU9VVDtcblxuICBsZXQgZXhlY0Z1bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghKGNtZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBjbWQgPSBbY21kXTtcbiAgICAgIH1cbiAgICAgIGxldCBhcmdzID0gdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLmNvbmNhdChjbWQpO1xuICAgICAgbG9nLmRlYnVnKGBSdW5uaW5nICcke3RoaXMuZXhlY3V0YWJsZS5wYXRofSAke3F1b3RlKGFyZ3MpfSdgKTtcbiAgICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIGFyZ3MsIG9wdHMpO1xuICAgICAgLy8gc29tZXRpbWVzIEFEQiBwcmludHMgb3V0IHdlaXJkIHN0ZG91dCB3YXJuaW5ncyB0aGF0IHdlIGRvbid0IHdhbnRcbiAgICAgIC8vIHRvIGluY2x1ZGUgaW4gYW55IG9mIHRoZSByZXNwb25zZSBkYXRhLCBzbyBsZXQncyBzdHJpcCBpdCBvdXRcbiAgICAgIHN0ZG91dCA9IHN0ZG91dC5yZXBsYWNlKExJTktFUl9XQVJOSU5HX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgIHJldHVybiBzdGRvdXQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyVGV4dCA9IGAke2UubWVzc2FnZX0sICR7ZS5zdGRvdXR9LCAke2Uuc3RkZXJyfWA7XG4gICAgICBjb25zdCBwcm90b2NvbEZhdWx0RXJyb3IgPSBQUk9UT0NPTF9GQVVMVF9FUlJPUl9SRUdFWFAudGVzdChlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGRldmljZU5vdEZvdW5kRXJyb3IgPSBERVZJQ0VfTk9UX0ZPVU5EX0VSUk9SX1JFR0VYUC50ZXN0KGVyclRleHQpO1xuICAgICAgY29uc3QgZGV2aWNlQ29ubmVjdGluZ0Vycm9yID0gREVWSUNFX0NPTk5FQ1RJTkdfRVJST1JfUkVHRVhQLnRlc3QoZXJyVGV4dCk7XG4gICAgICBpZiAocHJvdG9jb2xGYXVsdEVycm9yIHx8IGRldmljZU5vdEZvdW5kRXJyb3IgfHwgZGV2aWNlQ29ubmVjdGluZ0Vycm9yKSB7XG4gICAgICAgIGxvZy5pbmZvKGBFcnJvciBzZW5kaW5nIGNvbW1hbmQsIHJlY29ubmVjdGluZyBkZXZpY2UgYW5kIHJldHJ5aW5nOiAke2NtZH1gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwMCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0RGV2aWNlc1dpdGhSZXRyeSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS5jb2RlID09PSAwICYmIGUuc3Rkb3V0KSB7XG4gICAgICAgIGxldCBzdGRvdXQgPSBlLnN0ZG91dDtcbiAgICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnJlcGxhY2UoTElOS0VSX1dBUk5JTkdfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gc3Rkb3V0O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGV4ZWN1dGluZyBhZGJFeGVjLiBPcmlnaW5hbCBlcnJvcjogJyR7ZS5tZXNzYWdlfSc7IGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBhd2FpdCByZXRyeSgyLCBleGVjRnVuYyk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGdpdmVuIGNvbW1hbmQgdXNpbmcgX2FkYiBzaGVsbF8gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz58c3RyaW5nfSBjbWQgLSBUaGUgYXJyYXkgb2YgcmVzdCBjb21tYW5kIGxpbmUgcGFyYW1ldGVycyBvciBhIHNpbmdsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBtYXBwaW5nLiBTZWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vbm9kZS10ZWVuX3Byb2Nlc3N9XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQ29tbWFuZCdzIHN0ZG91dC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY29tbWFuZCByZXR1cm5lZCBub24temVybyBleGl0IGNvZGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNoZWxsID0gYXN5bmMgZnVuY3Rpb24gKGNtZCwgb3B0cyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCB0aGlzLmFkYkV4ZWMoXy5pc0FycmF5KGNtZCkgPyBbJ3NoZWxsJywgLi4uY21kXSA6IFsnc2hlbGwnLCBjbWRdLCBvcHRzKTtcbn07XG5cbnN5c3RlbUNhbGxNZXRob2RzLmNyZWF0ZVN1YlByb2Nlc3MgPSBmdW5jdGlvbiAoYXJncyA9IFtdKSB7XG4gIC8vIGFkZCB0aGUgZGVmYXVsdCBhcmd1bWVudHNcbiAgYXJncyA9IHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5jb25jYXQoYXJncyk7XG4gIGxvZy5kZWJ1ZyhgQ3JlYXRpbmcgQURCIHN1YnByb2Nlc3Mgd2l0aCBhcmdzOiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICByZXR1cm4gbmV3IFN1YlByb2Nlc3ModGhpcy5nZXRBZGJQYXRoKCksIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBhZGIgcG9ydC5cbiAqIEB0b2RvIGNhbiBwcm9iYWJseSBkZXByZWNhdGUgdGhpcyBub3cgdGhhdCB0aGUgbG9naWMgaXMganVzdCB0byByZWFkIHRoaXMuYWRiUG9ydFxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY3VycmVudCBhZGIgcG9ydCBudW1iZXIuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlNlcnZlclBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFkYlBvcnQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgZnJvbSBfYWRiIGRldml2ZXNfIG91dHB1dC5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIGNvbm5lY3RlZCBkZXZpY2VzLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5nZXRFbXVsYXRvclBvcnQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gIGxvZy5kZWJ1ZyhcIkdldHRpbmcgcnVubmluZyBlbXVsYXRvciBwb3J0XCIpO1xuICBpZiAodGhpcy5lbXVsYXRvclBvcnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbXVsYXRvclBvcnQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgZGV2aWNlcyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRGV2aWNlcygpO1xuICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZXNbMF0udWRpZCk7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVtdWxhdG9yIHBvcnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXZpY2VzIGNvbm5lY3RlZC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGVtdWxhdG9yIHBvcnQgYnkgcGFyc2luZyBlbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1TdHIgLSBFbXVsYXRvciBuYW1lIHN0cmluZy5cbiAqIEByZXR1cm4ge251bWJlcnxib29sZWFufSBFaXRoZXIgdGhlIGN1cnJlbnQgZW11bGF0b3IgcG9ydCBvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgIF9mYWxzZV8gaWYgcG9ydCBudW1iZXIgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyA9IGZ1bmN0aW9uIChlbVN0cikge1xuICBsZXQgcG9ydFBhdHRlcm4gPSAvZW11bGF0b3ItKFxcZCspLztcbiAgaWYgKHBvcnRQYXR0ZXJuLnRlc3QoZW1TdHIpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHBvcnRQYXR0ZXJuLmV4ZWMoZW1TdHIpWzFdLCAxMCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgbGlzdCBvZiBjdXJyZW50bHkgY29ubmVjdGVkIGVtdWxhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48RGV2aWNlPn0gVGhlIGxpc3Qgb2YgY29ubmVjdGVkIGRldmljZXMuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldENvbm5lY3RlZEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBsb2cuZGVidWcoXCJHZXR0aW5nIGNvbm5lY3RlZCBlbXVsYXRvcnNcIik7XG4gICAgbGV0IGRldmljZXMgPSBhd2FpdCB0aGlzLmdldENvbm5lY3RlZERldmljZXMoKTtcbiAgICBsZXQgZW11bGF0b3JzID0gW107XG4gICAgZm9yIChsZXQgZGV2aWNlIG9mIGRldmljZXMpIHtcbiAgICAgIGxldCBwb3J0ID0gdGhpcy5nZXRQb3J0RnJvbUVtdWxhdG9yU3RyaW5nKGRldmljZS51ZGlkKTtcbiAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgIGRldmljZS5wb3J0ID0gcG9ydDtcbiAgICAgICAgZW11bGF0b3JzLnB1c2goZGV2aWNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGAke2VtdWxhdG9ycy5sZW5ndGh9IGVtdWxhdG9yKHMpIGNvbm5lY3RlZGApO1xuICAgIHJldHVybiBlbXVsYXRvcnM7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgZW11bGF0b3JzLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IF9lbXVsYXRvclBvcnRfIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbVBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCB0byBiZSBzZXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnNldEVtdWxhdG9yUG9ydCA9IGZ1bmN0aW9uIChlbVBvcnQpIHtcbiAgdGhpcy5lbXVsYXRvclBvcnQgPSBlbVBvcnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaWRlbnRpZmllciBvZiB0aGUgY3VycmVudCBkZXZpY2UgKF90aGlzLmN1ckRldmljZUlkXykuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IC0gVGhlIGRldmljZSBpZGVudGlmaWVyLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5zZXREZXZpY2VJZCA9IGZ1bmN0aW9uIChkZXZpY2VJZCkge1xuICBsb2cuZGVidWcoYFNldHRpbmcgZGV2aWNlIGlkIHRvICR7ZGV2aWNlSWR9YCk7XG4gIHRoaXMuY3VyRGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgbGV0IGFyZ3NIYXNEZXZpY2UgPSB0aGlzLmV4ZWN1dGFibGUuZGVmYXVsdEFyZ3MuaW5kZXhPZignLXMnKTtcbiAgaWYgKGFyZ3NIYXNEZXZpY2UgIT09IC0xKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBvbGQgZGV2aWNlIGlkIGZyb20gdGhlIGFyZ3VtZW50c1xuICAgIHRoaXMuZXhlY3V0YWJsZS5kZWZhdWx0QXJncy5zcGxpY2UoYXJnc0hhc0RldmljZSwgMik7XG4gIH1cbiAgdGhpcy5leGVjdXRhYmxlLmRlZmF1bHRBcmdzLnB1c2goJy1zJywgZGV2aWNlSWQpO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRoZSBjdXJyZW50IGRldmljZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtEZXZpY2V9IGRldmljZU9iaiAtIFRoZSBkZXZpY2Ugb2JqZWN0IHRvIGJlIHNldC5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuc2V0RGV2aWNlID0gZnVuY3Rpb24gKGRldmljZU9iaikge1xuICBsZXQgZGV2aWNlSWQgPSBkZXZpY2VPYmoudWRpZDtcbiAgbGV0IGVtUG9ydCA9IHRoaXMuZ2V0UG9ydEZyb21FbXVsYXRvclN0cmluZyhkZXZpY2VJZCk7XG4gIHRoaXMuc2V0RW11bGF0b3JQb3J0KGVtUG9ydCk7XG4gIHRoaXMuc2V0RGV2aWNlSWQoZGV2aWNlSWQpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gRW11bGF0b3IgbmFtZS5cbiAqIEByZXR1cm4gez9EZXZpY2V9IEN1cnJlbnRseSBydW5uaW5nIGVtdWxhdG9yIG9yIF9udWxsXy5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZ2V0UnVubmluZ0FWRCA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lKSB7XG4gIHRyeSB7XG4gICAgbG9nLmRlYnVnKGBUcnlpbmcgdG8gZmluZCAke2F2ZE5hbWV9IGVtdWxhdG9yYCk7XG4gICAgbGV0IGVtdWxhdG9ycyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGVkRW11bGF0b3JzKCk7XG4gICAgZm9yIChsZXQgZW11bGF0b3Igb2YgZW11bGF0b3JzKSB7XG4gICAgICB0aGlzLnNldEVtdWxhdG9yUG9ydChlbXVsYXRvci5wb3J0KTtcbiAgICAgIGxldCBydW5uaW5nQVZETmFtZSA9IGF3YWl0IHRoaXMuc2VuZFRlbG5ldENvbW1hbmQoXCJhdmQgbmFtZVwiKTtcbiAgICAgIGlmIChhdmROYW1lID09PSBydW5uaW5nQVZETmFtZSkge1xuICAgICAgICBsb2cuZGVidWcoYEZvdW5kIGVtdWxhdG9yICR7YXZkTmFtZX0gaW4gcG9ydCAke2VtdWxhdG9yLnBvcnR9YCk7XG4gICAgICAgIHRoaXMuc2V0RGV2aWNlSWQoZW11bGF0b3IudWRpZCk7XG4gICAgICAgIHJldHVybiBlbXVsYXRvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nLmRlYnVnKGBFbXVsYXRvciAke2F2ZE5hbWV9IG5vdCBydW5uaW5nYCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZELiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBlbXVsYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIEVtdWxhdG9yIG5hbWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zIFsyMDAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB3YWl0IHVudGlsIGF0IGxlYXN0IG9uZSBydW5uaW5nIEFWRCBvYmplY3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIGRldGVjdGVkLlxuICogQHJldHVybiB7P0RldmljZX0gQ3VycmVudGx5IHJ1bm5pbmcgZW11bGF0b3Igb3IgX251bGxfLlxuICogQHRocm93cyB7RXJyb3J9IElmIG5vIGRldmljZSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gdGhlIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldFJ1bm5pbmdBVkRXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSwgdGltZW91dE1zID0gMjAwMDApIHtcbiAgdHJ5IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHdoaWxlICgoRGF0ZS5ub3coKSAtIHN0YXJ0KSA8IHRpbWVvdXRNcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJ1bm5pbmdBVkQgPSBhd2FpdCB0aGlzLmdldFJ1bm5pbmdBVkQoYXZkTmFtZS5yZXBsYWNlKCdAJywgJycpKTtcbiAgICAgICAgaWYgKHJ1bm5pbmdBVkQpIHtcbiAgICAgICAgICByZXR1cm4gcnVubmluZ0FWRDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICBsb2cuaW5mbyhgQ291bGRuJ3QgZ2V0IHJ1bm5pbmcgQVZELCB3aWxsIHJldHJ5LiBFcnJvciB3YXM6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgLy8gY29vbCBkb3duXG4gICAgICBhd2FpdCBzbGVlcCgyMDApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7YXZkTmFtZX0gZW11bGF0b3IuYCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGdldHRpbmcgQVZEIHdpdGggcmV0cnkuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTaHV0ZG93biBhbGwgcnVubmluZyBlbXVsYXRvcnMgYnkga2lsbGluZyB0aGVpciBwcm9jZXNzZXMuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIGtpbGxpbmcgdG9vbCByZXR1cm5lZCBub24temVybyByZXR1cm4gY29kZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEFsbEVtdWxhdG9ycyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgbGV0IGNtZCwgYXJncztcbiAgaWYgKHN5c3RlbS5pc1dpbmRvd3MoKSkge1xuICAgIGNtZCA9ICdUQVNLS0lMTCc7XG4gICAgYXJncyA9IFsnVEFTS0tJTEwnLCAnL0lNJywgJ2VtdWxhdG9yLmV4ZSddO1xuICB9IGVsc2Uge1xuICAgIGNtZCA9ICcvdXNyL2Jpbi9raWxsYWxsJztcbiAgICBhcmdzID0gWyctbScsICdlbXVsYXRvcionXTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IGV4ZWMoY21kLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3Iga2lsbGluZyBlbXVsYXRvcnMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBLaWxsIGVtdWxhdG9yIHdpdGggdGhlIGdpdmVuIG5hbWUuIE5vIGVycm9yXG4gKiBpcyB0aHJvd24gaXMgZ2l2ZW4gYXZkIGRvZXMgbm90IGV4aXN0L2lzIG5vdCBydW5uaW5nLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlbXVsYXRvciB0byBiZSBraWxsZWQuIElmIGVtcHR5LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGN1cnJlbnQgZW11bGF0b3Igd2lsbCBiZSBraWxsZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVtdWxhdG9yIHdhcyBraWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMua2lsbEVtdWxhdG9yID0gYXN5bmMgZnVuY3Rpb24gKGF2ZE5hbWUpIHtcbiAgaWYgKHV0aWwuaGFzVmFsdWUoYXZkTmFtZSkpIHtcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkICcke2F2ZE5hbWV9J2ApO1xuICAgIGNvbnN0IGRldmljZSA9IGF3YWl0IHRoaXMuZ2V0UnVubmluZ0FWRChhdmROYW1lKTtcbiAgICBpZiAoIWRldmljZSkge1xuICAgICAgbG9nLmluZm8oYE5vIGF2ZCB3aXRoIG5hbWUgJyR7YXZkTmFtZX0nIHJ1bm5pbmcuIFNraXBwaW5nIGtpbGwgc3RlcC5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8ga2lsbGluZyB0aGUgY3VycmVudCBhdmRcbiAgICBsb2cuZGVidWcoYEtpbGxpbmcgYXZkIHdpdGggaWQgJyR7dGhpcy5jdXJEZXZpY2VJZH0nYCk7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmlzRW11bGF0b3JDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nLmRlYnVnKGBFbXVsYXRvciB3aXRoIGlkICcke3RoaXMuY3VyRGV2aWNlSWR9JyBub3QgY29ubmVjdGVkLiBTa2lwcGluZyBraWxsIHN0ZXBgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXdhaXQgdGhpcy5hZGJFeGVjKFsnZW11JywgJ2tpbGwnXSk7XG4gIGxvZy5pbmZvKGBTdWNjZXNzZnVsbHkga2lsbGVkIGVtdWxhdG9yYCk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTdGFydCBhbiBlbXVsYXRvciB3aXRoIGdpdmVuIHBhcmFtZXRlcnMgYW5kIHdhaXQgdW50aWwgaXQgaXMgZnVsbCBzdGFydGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdmROYW1lIC0gVGhlIG5hbWUgb2YgYW4gZXhpc3RpbmcgZW11bGF0b3IuXG4gKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fHN0cmluZ30gYXZkQXJncyAtIEFkZGl0aW9uYWwgZW11bGF0b3IgY29tbWFuZCBsaW5lIGFyZ3VtZW50LlxuICogQHBhcmFtIHs/c3RyaW5nfSBsYW5ndWFnZSAtIEVtdWxhdG9yIHN5c3RlbSBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7P2NvbnRyeX0gY291bnRyeSAtIEVtdWxhdG9yIHN5c3RlbSBjb3VudHJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGF2ZExhdW5jaFRpbWVvdXQgWzYwMDAwXSAtIEVtdWxhdG9yIHN0YXJ0dXAgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlUaW1lcyBbMV0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc3RhcnR1cCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBmYWlscyB0byBzdGFydCB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmxhdW5jaEFWRCA9IGFzeW5jIGZ1bmN0aW9uIChhdmROYW1lLCBhdmRBcmdzLCBsYW5ndWFnZSwgY291bnRyeSxcbiAgYXZkTGF1bmNoVGltZW91dCA9IDYwMDAwLCBhdmRSZWFkeVRpbWVvdXQgPSA2MDAwMCwgcmV0cnlUaW1lcyA9IDEpIHtcbiAgbG9nLmRlYnVnKGBMYXVuY2hpbmcgRW11bGF0b3Igd2l0aCBBVkQgJHthdmROYW1lfSwgbGF1bmNoVGltZW91dCBgICtcbiAgICAgICAgICAgIGAke2F2ZExhdW5jaFRpbWVvdXR9bXMgYW5kIHJlYWR5VGltZW91dCAke2F2ZFJlYWR5VGltZW91dH1tc2ApO1xuICBsZXQgZW11bGF0b3JCaW5hcnlQYXRoID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKFwiZW11bGF0b3JcIik7XG4gIGlmIChhdmROYW1lWzBdID09PSBcIkBcIikge1xuICAgIGF2ZE5hbWUgPSBhdmROYW1lLnN1YnN0cigxKTtcbiAgfVxuICBhd2FpdCB0aGlzLmNoZWNrQXZkRXhpc3QoYXZkTmFtZSk7XG4gIGxldCBsYXVuY2hBcmdzID0gW1wiLWF2ZFwiLCBhdmROYW1lXTtcbiAgaWYgKF8uaXNTdHJpbmcobGFuZ3VhZ2UpKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIEFuZHJvaWQgRGV2aWNlIExhbmd1YWdlIHRvICR7bGFuZ3VhZ2V9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmxhbmd1YWdlPSR7bGFuZ3VhZ2UudG9Mb3dlckNhc2UoKX1gKTtcbiAgfVxuICBpZiAoXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBDb3VudHJ5IHRvICR7Y291bnRyeX1gKTtcbiAgICBsYXVuY2hBcmdzLnB1c2goXCItcHJvcFwiLCBgcGVyc2lzdC5zeXMuY291bnRyeT0ke2NvdW50cnkudG9VcHBlckNhc2UoKX1gKTtcbiAgfVxuICBsZXQgbG9jYWxlO1xuICBpZiAoXy5pc1N0cmluZyhsYW5ndWFnZSkgJiYgXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvY2FsZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCkgKyBcIi1cIiArIGNvdW50cnkudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGxhbmd1YWdlKSkge1xuICAgIGxvY2FsZSA9IGxhbmd1YWdlLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhjb3VudHJ5KSkge1xuICAgIGxvY2FsZSA9IGNvdW50cnk7XG4gIH1cbiAgaWYgKF8uaXNTdHJpbmcobG9jYWxlKSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBBbmRyb2lkIERldmljZSBMb2NhbGUgdG8gJHtsb2NhbGV9YCk7XG4gICAgbGF1bmNoQXJncy5wdXNoKFwiLXByb3BcIiwgYHBlcnNpc3Quc3lzLmxvY2FsZT0ke2xvY2FsZX1gKTtcbiAgfVxuICBpZiAoIV8uaXNFbXB0eShhdmRBcmdzKSkge1xuICAgIGxhdW5jaEFyZ3MucHVzaCguLi4oXy5pc0FycmF5KGF2ZEFyZ3MpID8gYXZkQXJncyA6IGF2ZEFyZ3Muc3BsaXQoJyAnKSkpO1xuICB9XG4gIGxvZy5kZWJ1ZyhgUnVubmluZyAnJHtlbXVsYXRvckJpbmFyeVBhdGh9JyB3aXRoIGFyZ3M6ICR7SlNPTi5zdHJpbmdpZnkobGF1bmNoQXJncyl9YCk7XG4gIGxldCBwcm9jID0gbmV3IFN1YlByb2Nlc3MoZW11bGF0b3JCaW5hcnlQYXRoLCBsYXVuY2hBcmdzKTtcbiAgYXdhaXQgcHJvYy5zdGFydCgwKTtcbiAgcHJvYy5vbignb3V0cHV0JywgKHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgZm9yIChsZXQgbGluZSBvZiAoc3Rkb3V0IHx8IHN0ZGVyciB8fCAnJykuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKSkge1xuICAgICAgbG9nLmluZm8oYFtBVkQgT1VUUFVUXSAke2xpbmV9YCk7XG4gICAgfVxuICB9KTtcbiAgcHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcbiAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXVsYXRvciBhdmQgJHthdmROYW1lfSBleGl0IHdpdGggY29kZSAke2NvZGV9LCBzaWduYWwgJHtzaWduYWx9YCk7XG4gICAgfVxuICB9KTtcbiAgYXdhaXQgcmV0cnkocmV0cnlUaW1lcywgdGhpcy5nZXRSdW5uaW5nQVZEV2l0aFJldHJ5LmJpbmQodGhpcyksIGF2ZE5hbWUsIGF2ZExhdW5jaFRpbWVvdXQpO1xuICBhd2FpdCB0aGlzLndhaXRGb3JFbXVsYXRvclJlYWR5KGF2ZFJlYWR5VGltZW91dCk7XG4gIHJldHVybiBwcm9jO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBREJWZXJzaW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvblN0cmluZyAtIEFEQiB2ZXJzaW9uIGFzIGEgc3RyaW5nLlxuICogQHByb3BlcnR5IHtmbG9hdH0gdmVyc2lvbkZsb2F0IC0gVmVyc2lvbiBudW1iZXIgYXMgZmxvYXQgdmFsdWUgKHVzZWZ1bCBmb3IgY29tcGFyaXNvbikuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWFqb3IgLSBNYWpvciB2ZXJzaW9uIG51bWJlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5vciAtIE1pbm9yIHZlcnNpb24gbnVtYmVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhdGNoIC0gUGF0Y2ggdmVyc2lvbiBudW1iZXIuXG4gKi9cblxuLyoqXG4gKiBHZXQgdGhlIGFkYiB2ZXJzaW9uLiBUaGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIGlzIGNhY2hlZC5cbiAqXG4gKiBAcmV0dXJuIHtBREJWZXJzaW9ufSBUaGUgY3VycmVudCBhZGIgdmVyc2lvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCBpcyBub3QgcG9zc2libGUgdG8gcGFyc2UgYWRiIHZlcnNpb24uXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmdldEFkYlZlcnNpb24gPSBfLm1lbW9pemUoYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCBhZGJWZXJzaW9uID0gKGF3YWl0IHRoaXMuYWRiRXhlYygndmVyc2lvbicpKVxuICAgICAgLnJlcGxhY2UoL0FuZHJvaWRcXHNEZWJ1Z1xcc0JyaWRnZVxcc3ZlcnNpb25cXHMoW1xcZFxcLl0qKVtcXHNcXHdcXC1dKi8sIFwiJDFcIik7XG4gICAgbGV0IHBhcnRzID0gYWRiVmVyc2lvbi5zcGxpdCgnLicpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uU3RyaW5nOiBhZGJWZXJzaW9uLFxuICAgICAgdmVyc2lvbkZsb2F0OiBwYXJzZUZsb2F0KGFkYlZlcnNpb24pLFxuICAgICAgbWFqb3I6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICBtaW5vcjogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgIHBhdGNoOiBwYXJ0c1syXSA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZ2V0dGluZyBhZGIgdmVyc2lvbi4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBTdGRlcnI6ICckeyhlLnN0ZGVyciB8fCAnJykudHJpbSgpfSc7IENvZGU6ICcke2UuY29kZX0nYCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENoZWNrIGlmIGdpdmVuIGVtdWxhdG9yIGV4aXN0cyBpbiB0aGUgbGlzdCBvZiBhdmFpbGFibGUgYXZkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXZkTmFtZSAtIFRoZSBuYW1lIG9mIGVtdWxhdG9yIHRvIHZlcmlmeSBmb3IgZXhpc3RlbmNlLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciB3aXRoIGdpdmVuIG5hbWUgZG9lcyBub3QgZXhpc3QuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmNoZWNrQXZkRXhpc3QgPSBhc3luYyBmdW5jdGlvbiAoYXZkTmFtZSkge1xuICBsZXQgY21kLCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgY21kID0gYXdhaXQgdGhpcy5nZXRTZGtCaW5hcnlQYXRoKCdlbXVsYXRvcicpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWMoY21kLCBbJy1saXN0LWF2ZHMnXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsZXQgdW5rbm93bk9wdGlvbkVycm9yID0gbmV3IFJlZ0V4cChcInVua25vd24gb3B0aW9uOiAtbGlzdC1hdmRzXCIsIFwiaVwiKS50ZXN0KGUuc3RkZXJyKTtcbiAgICBpZiAoIXVua25vd25PcHRpb25FcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBleGVjdXRpbmcgY2hlY2tBdmRFeGlzdC4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nOyBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgU3RkZXJyOiAnJHsoZS5zdGRlcnIgfHwgJycpLnRyaW0oKX0nOyBDb2RlOiAnJHtlLmNvZGV9J2ApO1xuXG4gICAgfVxuICAgIGNvbnN0IHNka1ZlcnNpb24gPSBhd2FpdCBnZXRTZGtUb29sc1ZlcnNpb24oKTtcbiAgICBsZXQgYmluYXJ5TmFtZSA9ICdhbmRyb2lkJztcbiAgICBpZiAoc2RrVmVyc2lvbikge1xuICAgICAgaWYgKHNka1ZlcnNpb24ubWFqb3IgPj0gMjUpIHtcbiAgICAgICAgYmluYXJ5TmFtZSA9ICdhdmRtYW5hZ2VyJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9nLndhcm4oYERlZmF1bHRpbmcgYmluYXJ5IG5hbWUgdG8gJyR7YmluYXJ5TmFtZX0nLCBiZWNhdXNlIFNESyB2ZXJzaW9uIGNhbm5vdCBiZSBwYXJzZWRgKTtcbiAgICB9XG4gICAgLy8gSWYgLWxpc3QtYXZkcyBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSwgdXNlIGFuZHJvaWQgY29tbWFuZCBhcyBhbiBhbHRlcm5hdGl2ZVxuICAgIGNtZCA9IGF3YWl0IHRoaXMuZ2V0U2RrQmluYXJ5UGF0aChiaW5hcnlOYW1lKTtcbiAgICByZXN1bHQgPSBhd2FpdCBleGVjKGNtZCwgWydsaXN0JywgJ2F2ZCcsICctYyddKTtcbiAgfVxuICBpZiAocmVzdWx0LnN0ZG91dC5pbmRleE9mKGF2ZE5hbWUpID09PSAtMSkge1xuICAgIGxldCBleGlzdGluZ3MgPSBgKCR7cmVzdWx0LnN0ZG91dC50cmltKCkucmVwbGFjZSgvW1xcbl0vZywgJyksICgnKX0pYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEF2ZCAnJHthdmROYW1lfScgaXMgbm90IGF2YWlsYWJsZS4gcGxlYXNlIHNlbGVjdCB5b3VyIGF2ZCBuYW1lIGZyb20gb25lIG9mIHRoZXNlOiAnJHtleGlzdGluZ3N9J2ApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGVtdWxhdG9yIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRNcyBbMjAwMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0LlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBlbXVsYXRvciBpcyBub3QgcmVhZHkgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy53YWl0Rm9yRW11bGF0b3JSZWFkeSA9IGFzeW5jIGZ1bmN0aW9uICh0aW1lb3V0TXMgPSAyMDAwMCkge1xuICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICBsb2cuZGVidWcoXCJXYWl0aW5nIHVudGlsIGVtdWxhdG9yIGlzIHJlYWR5XCIpO1xuICB3aGlsZSAoKERhdGUubm93KCkgLSBzdGFydCkgPCB0aW1lb3V0TXMpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IHN0ZG91dCA9IGF3YWl0IHRoaXMuc2hlbGwoW1wiZ2V0cHJvcFwiLCBcImluaXQuc3ZjLmJvb3RhbmltXCJdKTtcbiAgICAgIGlmIChzdGRvdXQuaW5kZXhPZignc3RvcHBlZCcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG4gICAgYXdhaXQgc2xlZXAoMzAwMCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFbXVsYXRvciBub3QgcmVhZHknKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZGV2aWNlIGlzIHJlYWR5IHRvIGFjY2VwdCBmdXJ0aGVyIGNvbW1hbmRzIChib290aW5nIGNvbXBsZXRlZCkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFwcERldmljZVJlYWR5VGltZW91dCBbMzBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGV2aWNlIGlzIG5vdCByZWFkeSB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLndhaXRGb3JEZXZpY2UgPSBhc3luYyBmdW5jdGlvbiAoYXBwRGV2aWNlUmVhZHlUaW1lb3V0ID0gMzApIHtcbiAgdGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQgPSBhcHBEZXZpY2VSZWFkeVRpbWVvdXQ7XG4gIGNvbnN0IHJldHJpZXMgPSAzO1xuICBjb25zdCB0aW1lb3V0ID0gcGFyc2VJbnQodGhpcy5hcHBEZXZpY2VSZWFkeVRpbWVvdXQsIDEwKSAvIHJldHJpZXMgKiAxMDAwO1xuICBhd2FpdCByZXRyeShyZXRyaWVzLCBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYWRiRXhlYygnd2FpdC1mb3ItZGV2aWNlJywge3RpbWVvdXR9KTtcbiAgICAgIGF3YWl0IHRoaXMucGluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVzdGFydEFkYigpO1xuICAgICAgYXdhaXQgdGhpcy5nZXRDb25uZWN0ZWREZXZpY2VzKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIHdhaXRpbmcgZm9yIGRldmljZS4gT3JpZ2luYWwgZXJyb3I6ICcke2UubWVzc2FnZX0nLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBgUmV0cnlpbmcgYnkgcmVzdGFydGluZyBBREJgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWJvb3QgdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCB3YWl0IHVudGlsIGl0IGlzIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cmllcyBbREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVNdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlYm9vdCByZXRyaWVzLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZXZpY2UgZmFpbGVkIHRvIHJlYm9vdCBhbmQgbnVtYmVyIG9mIHJldHJpZXMgaXMgZXhjZWVkZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnJlYm9vdCA9IGFzeW5jIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9BREJfUkVCT09UX1JFVFJJRVMpIHtcbiAgdHJ5IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zaGVsbChbJ3N0b3AnXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignbXVzdCBiZSByb290JykgPT09IC0xKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgZGV2aWNlIG5lZWRzIGFkYiB0byBiZSBydW5uaW5nIGFzIHJvb3QgdG8gc3RvcC5cbiAgICAgIC8vIHNvIHRyeSB0byByZXN0YXJ0IHRoZSBkYWVtb25cbiAgICAgIGxvZy5kZWJ1ZygnRGV2aWNlIHJlcXVpcmVzIGFkYiB0byBiZSBydW5uaW5nIGFzIHJvb3QgaW4gb3JkZXIgdG8gcmVib290LiBSZXN0YXJ0aW5nIGRhZW1vbicpO1xuICAgICAgYXdhaXQgdGhpcy5yb290KCk7XG4gICAgICBhd2FpdCB0aGlzLnNoZWxsKFsnc3RvcCddKTtcbiAgICB9XG4gICAgYXdhaXQgQi5kZWxheSgyMDAwKTsgLy8gbGV0IHRoZSBlbXUgZmluaXNoIHN0b3BwaW5nO1xuICAgIGF3YWl0IHRoaXMuc2V0RGV2aWNlUHJvcGVydHkoJ3N5cy5ib290X2NvbXBsZXRlZCcsIDApO1xuICAgIGF3YWl0IHRoaXMuc2hlbGwoWydzdGFydCddKTtcbiAgICBhd2FpdCByZXRyeUludGVydmFsKHJldHJpZXMsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBib290ZWQgPSBhd2FpdCB0aGlzLmdldERldmljZVByb3BlcnR5KCdzeXMuYm9vdF9jb21wbGV0ZWQnKTtcbiAgICAgIGlmIChib290ZWQgPT09ICcxJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBzdGFjayB0cmFjZSwgc28gbm8gbG9nLmVycm9yQW5kVGhyb3dcbiAgICAgICAgbGV0IG1zZyA9ICdXYWl0aW5nIGZvciByZWJvb3QuIFRoaXMgdGFrZXMgdGltZSc7XG4gICAgICAgIGxvZy5kZWJ1Zyhtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCB0aGlzLnVucm9vdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN3aXRjaCBhZGIgc2VydmVyIHRvIHJvb3QgbW9kZS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIG9mIHRoZSBzd2l0Y2ggd2FzIHN1Y2Nlc3NmdWwgb3IgZmFsc2VcbiAqICAgICAgICAgICAgICAgICAgIGlmIHRoZSBzd2l0Y2ggZmFpbGVkLlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5yb290ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWModGhpcy5leGVjdXRhYmxlLnBhdGgsIFsncm9vdCddKTtcblxuICAgIC8vIG9uIHJlYWwgZGV2aWNlcyBpbiBzb21lIHNpdHVhdGlvbnMgd2UgZ2V0IGFuIGVycm9yIGluIHRoZSBzdGRvdXRcbiAgICBpZiAoc3Rkb3V0ICYmIHN0ZG91dC5pbmRleE9mKCdhZGJkIGNhbm5vdCBydW4gYXMgcm9vdCcpICE9PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0ZG91dC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2cud2FybihgVW5hYmxlIHRvIHJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBTd2l0Y2ggYWRiIHNlcnZlciB0byBub24tcm9vdCBtb2RlLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb2YgdGhlIHN3aXRjaCB3YXMgc3VjY2Vzc2Z1bCBvciBmYWxzZVxuICogICAgICAgICAgICAgICAgICAgaWYgdGhlIHN3aXRjaCBmYWlsZWQuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLnVucm9vdCA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjKHRoaXMuZXhlY3V0YWJsZS5wYXRoLCBbJ3Vucm9vdCddKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbG9nLndhcm4oYFVuYWJsZSB0byB1bnJvb3QgYWRiIGRhZW1vbjogJyR7ZXJyLm1lc3NhZ2V9Jy4gQ29udGludWluZ2ApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBWZXJpZnkgd2hldGhlciBhIHJlbW90ZSBwYXRoIGV4aXN0cyBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcmVtb3RlIHBhdGggdG8gdmVyaWZ5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBleGlzdHMgb24gdGhlIGRldmljZS5cbiAqL1xuc3lzdGVtQ2FsbE1ldGhvZHMuZmlsZUV4aXN0cyA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoKSB7XG4gIGxldCBmaWxlcyA9IGF3YWl0IHRoaXMubHMocmVtb3RlUGF0aCk7XG4gIHJldHVybiBmaWxlcy5sZW5ndGggPiAwO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIG91dHB1dCBvZiBfbHNfIGNvbW1hbmQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoICh0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIF9sc18gY29tbWFuZCkuXG4gKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBvcHRzIFtbXV0gLSBBZGRpdGlvbmFsIF9sc18gb3B0aW9ucy5cbiAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fSBUaGUgX2xzXyBvdXRwdXQgYXMgYW4gYXJyYXkgb2Ygc3BsaXQgbGluZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgQW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQgb2YgdGhlIGdpdmVuIF9yZW1vdGVQYXRoX1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIGRvZXMgbm90IGV4aXN0LlxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5scyA9IGFzeW5jIGZ1bmN0aW9uIChyZW1vdGVQYXRoLCBvcHRzID0gW10pIHtcbiAgdHJ5IHtcbiAgICBsZXQgYXJncyA9IFsnbHMnLCAuLi5vcHRzLCByZW1vdGVQYXRoXTtcbiAgICBsZXQgc3Rkb3V0ID0gYXdhaXQgdGhpcy5zaGVsbChhcmdzKTtcbiAgICBsZXQgbGluZXMgPSBzdGRvdXQuc3BsaXQoXCJcXG5cIik7XG4gICAgcmV0dXJuIGxpbmVzLm1hcCgobCkgPT4gbC50cmltKCkpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuZmlsdGVyKChsKSA9PiBsLmluZGV4T2YoXCJObyBzdWNoIGZpbGVcIikgPT09IC0xKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ05vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgcGFydGljdWxhciBmaWxlIGxvY2F0ZWQgb24gdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIHRvIHRoZSBmaWxlLlxuICogQHJldHVybiB7bnVtYmVyfSBGaWxlIHNpemUgaW4gYnl0ZXMuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGdldHRpbmcgdGhlIHNpemUgb2YgdGhlIGdpdmVuIGZpbGUuXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmZpbGVTaXplID0gYXN5bmMgZnVuY3Rpb24gKHJlbW90ZVBhdGgpIHtcbiAgdHJ5IHtcbiAgICBsZXQgZmlsZXMgPSBhd2FpdCB0aGlzLmxzKHJlbW90ZVBhdGgsIFsnLWxhJ10pO1xuICAgIGlmIChmaWxlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVtb3RlIHBhdGggaXMgbm90IGEgZmlsZWApO1xuICAgIH1cbiAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yL2ZPczRQNC8zXG4gICAgbGV0IG1hdGNoID0gL1xccyhcXGQrKVxccytcXGR7NH0tXFxkezJ9LVxcZHsyfS8uZXhlYyhmaWxlc1swXSk7XG4gICAgaWYgKCFtYXRjaCB8fCBfLmlzTmFOKHBhcnNlSW50KG1hdGNoWzFdLCAxMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBzaXplIGZyb20gbGlzdCBvdXRwdXQ6ICcke2ZpbGVzWzBdfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBmaWxlIHNpemUgZm9yICcke3JlbW90ZVBhdGh9JzogJHtlcnIubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBJbnN0YWxscyB0aGUgZ2l2ZW4gY2VydGlmaWNhdGUgb24gYSByb290ZWQgcmVhbCBkZXZpY2Ugb3JcbiAqIGFuIGVtdWxhdG9yLiBUaGUgZW11bGF0b3IgbXVzdCBiZSBleGVjdXRlZCB3aXRoIGAtd3JpdGFibGUtc3lzdGVtYFxuICogY29tbWFuZCBsaW5lIG9wdGlvbiBhbmQgYWRiIGRhZW1vbiBzaG91bGQgYmUgcnVubmluZyBpbiByb290XG4gKiBtb2RlIGZvciB0aGlzIG1ldGhvZCB0byB3b3JrIHByb3Blcmx5LiBUaGUgbWV0aG9kIGFsc28gcmVxdWlyZXNcbiAqIG9wZW5zc2wgdG9vbCB0byBiZSBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbS5cbiAqIFJlYWQgaHR0cHM6Ly9naXRodWIuY29tL2FwcGl1bS9hcHBpdW0vaXNzdWVzLzEwOTY0XG4gKiBmb3IgbW9yZSBkZXRhaWxzIG9uIHRoaXMgdG9waWNcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGNlcnQgLSBiYXNlNjQtZGVjb2RlZCBjb250ZW50IG9mIHRoZSBhY3R1YWwgY2VydGlmaWNhdGVcbiAqIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9yIGEgYnVmZmVyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgb3BlbnNzbCB0b29sIGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIGRlc3RpbmF0aW9uIHN5c3RlbVxuICogb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluc3RhbGxpbmcgdGhlIGNlcnRpZmljYXRlXG4gKi9cbnN5c3RlbUNhbGxNZXRob2RzLmluc3RhbGxNaXRtQ2VydGlmaWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoY2VydCkge1xuICBjb25zdCBvcGVuU3NsID0gYXdhaXQgZ2V0T3BlblNzbEZvck9zKCk7XG5cbiAgaWYgKCFfLmlzQnVmZmVyKGNlcnQpKSB7XG4gICAgY2VydCA9IEJ1ZmZlci5mcm9tKGNlcnQsICdiYXNlNjQnKTtcbiAgfVxuXG4gIGNvbnN0IHRlbXBDZXJ0ID0gYXdhaXQgdGVtcERpci5vcGVuKHtcbiAgICBwcmVmaXg6ICdjZXJ0JyxcbiAgICBzdWZmaXg6ICcuY2VyJ1xuICB9KTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodGVtcENlcnQucGF0aCwgY2VydCk7XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLW5vb3V0JywgJy1oYXNoJywgJy1pbicsIHRlbXBDZXJ0LnBhdGhdKTtcbiAgICBjb25zdCBjZXJ0SGFzaCA9IHN0ZG91dC50cmltKCk7XG4gICAgbG9nLmRlYnVnKGBHb3QgY2VydGlmaWNhdGUgaGFzaDogJHtjZXJ0SGFzaH1gKTtcbiAgICBsb2cuZGVidWcoJ1ByZXBhcmluZyBjZXJ0aWZpY2F0ZSBjb250ZW50Jyk7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLCAnLWluJywgdGVtcENlcnQucGF0aF0sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBsZXQgZHN0Q2VydENvbnRlbnQgPSBzdGRvdXQ7XG4gICAgKHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhvcGVuU3NsLCBbJ3g1MDknLFxuICAgICAgJy1pbicsIHRlbXBDZXJ0LnBhdGgsXG4gICAgICAnLXRleHQnLFxuICAgICAgJy1maW5nZXJwcmludCcsXG4gICAgICAnLW5vb3V0J10sIHtpc0J1ZmZlcjogdHJ1ZX0pKTtcbiAgICBkc3RDZXJ0Q29udGVudCA9IGRzdENlcnRDb250ZW50LmNvbmNhdChzdGRvdXQpO1xuICAgIGNvbnN0IGRzdENlcnQgPSBhd2FpdCB0ZW1wRGlyLm9wZW4oe1xuICAgICAgcHJlZml4OiBjZXJ0SGFzaCxcbiAgICAgIHN1ZmZpeDogJy4wJ1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0Q2VydC5wYXRoLCBkc3RDZXJ0Q29udGVudCk7XG4gICAgICBsb2cuZGVidWcoJ01vdW50aW5nIC9zeXN0ZW0gZW5kcG9pbnQnKTtcbiAgICAgIGF3YWl0IHRoaXMuc2hlbGwoWydtb3VudCcsICctbycsICdydyxyZW1vdW50JywgJy9zeXN0ZW0nXSk7XG4gICAgICBsb2cuZGVidWcoYFVwbG9hZGluZyB0aGUgZ2VuZXJhdGVkIGNlcnRpZmljYXRlIGZyb20gJyR7ZHN0Q2VydC5wYXRofScgdG8gJyR7Q0VSVFNfUk9PVH0nYCk7XG4gICAgICBhd2FpdCB0aGlzLnB1c2goZHN0Q2VydC5wYXRoLCBDRVJUU19ST09UKTtcbiAgICAgIGxvZy5kZWJ1ZygnUmVtb3VudGluZyB0aGUgcmVtb3RlIGZpbGUgc3lzdGVtJyk7XG4gICAgICBhd2FpdCB0aGlzLmFkYkV4ZWMoWydyZW1vdW50J10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBmcy5jbG9zZShkc3RDZXJ0LmZkKTtcbiAgICAgIGF3YWl0IGZzLnJpbXJhZihkc3RDZXJ0LnBhdGgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5qZWN0IHRoZSBjdXN0b20gY2VydGlmaWNhdGUuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgSXMgdGhlIGNlcnRpZmljYXRlIHByb3Blcmx5IGVuY29kZWQgaW50byBiYXNlNjQtc3RyaW5nPyBgICtcbiAgICAgICAgICAgICAgICAgICAgYERvIHlvdSBoYXZlIHJvb3QgcGVybWlzc2lvbnMgb24gdGhlIGRldmljZT8gYCArXG4gICAgICAgICAgICAgICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBmcy5jbG9zZSh0ZW1wQ2VydC5mZCk7XG4gICAgYXdhaXQgZnMucmltcmFmKHRlbXBDZXJ0LnBhdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSBnaXZlbiByb290IGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIG9uIHRoZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBjZXJ0IC0gYmFzZTY0LWRlY29kZWQgY29udGVudCBvZiB0aGUgYWN0dWFsIGNlcnRpZmljYXRlXG4gKiByZXByZXNlbnRlZCBhcyBhIHN0cmluZyBvciBhIGJ1ZmZlclxuICogQHRocm93cyB7RXJyb3J9IElmIG9wZW5zc2wgdG9vbCBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXN0aW5hdGlvbiBzeXN0ZW1cbiAqIG9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjaGVja2luZyB0aGUgY2VydGlmaWNhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBnaXZlbiBjZXJ0aWZpY2F0ZSBpcyBhbHJlYWR5IGluc3RhbGxlZFxuICovXG5zeXN0ZW1DYWxsTWV0aG9kcy5pc01pdG1DZXJ0aWZpY2F0ZUluc3RhbGxlZCA9IGFzeW5jIGZ1bmN0aW9uIChjZXJ0KSB7XG4gIGNvbnN0IG9wZW5Tc2wgPSBhd2FpdCBnZXRPcGVuU3NsRm9yT3MoKTtcbiAgY29uc3QgdGVtcENlcnQgPSBhd2FpdCB0ZW1wRGlyLm9wZW4oe1xuICAgIHByZWZpeDogJ2NlcnQnLFxuICAgIHN1ZmZpeDogJy5jZXInXG4gIH0pO1xuICBsZXQgY2VydEhhc2g7XG4gIHRyeSB7XG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKHRlbXBDZXJ0LnBhdGgsIGNlcnQpO1xuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMob3BlblNzbCwgWyd4NTA5JywgJy1ub291dCcsICctaGFzaCcsICctaW4nLCB0ZW1wQ2VydC5wYXRoXSk7XG4gICAgY2VydEhhc2ggPSBzdGRvdXQudHJpbSgpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXRyaWV2ZSB0aGUgY2VydGlmaWNhdGUgaGFzaC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJcyB0aGUgY2VydGlmaWNhdGUgcHJvcGVybHkgZW5jb2RlZCBpbnRvIGJhc2U2NC1zdHJpbmc/IGAgK1xuICAgICAgICAgICAgICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMuY2xvc2UodGVtcENlcnQuZmQpO1xuICAgIGF3YWl0IGZzLnJpbXJhZih0ZW1wQ2VydC5wYXRoKTtcbiAgfVxuICBjb25zdCBkc3RQYXRoID0gcGF0aC5wb3NpeC5yZXNvbHZlKENFUlRTX1JPT1QsIGAke2NlcnRIYXNofS4wYCk7XG4gIGxvZy5kZWJ1ZyhgQ2hlY2tpbmcgaWYgdGhlIGNlcnRpZmljYXRlIGlzIGFscmVhZHkgaW5zdGFsbGVkIGF0ICcke2RzdFBhdGh9J2ApO1xuICByZXR1cm4gYXdhaXQgdGhpcy5maWxlRXhpc3RzKGRzdFBhdGgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3lzdGVtQ2FsbE1ldGhvZHM7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
