'use strict';

var _extends = require('babel-runtime/helpers/extends')['default'];

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _toConsumableArray = require('babel-runtime/helpers/to-consumable-array')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _desiredCaps = require('./desired-caps');

var _appiumSupport = require('appium-support');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _protocolErrors = require('../protocol/errors');

// Takes primary caps object and merges it into a secondary caps object.
// (see https://www.w3.org/TR/webdriver/#dfn-merging-capabilities)
function mergeCaps() {
  var primary = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var secondary = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var result = _Object$assign({}, primary);

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(_lodash2['default'].toPairs(secondary)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2);

      var _name = _step$value[0];
      var value = _step$value[1];

      // Overwriting is not allowed. Primary and secondary must have different properties (w3c rule 4.4)
      if (!_lodash2['default'].isUndefined(primary[_name])) {
        throw new _protocolErrors.errors.InvalidArgumentError('property \'' + _name + '\' should not exist on both primary (' + JSON.stringify(primary) + ') and secondary (' + JSON.stringify(secondary) + ') object');
      }
      result[_name] = value;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return result;
}

// Validates caps against a set of constraints
function validateCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
  var skipPresenceConstraint = opts.skipPresenceConstraint;

  if (!_lodash2['default'].isPlainObject(caps)) {
    throw new _protocolErrors.errors.InvalidArgumentError('must be a JSON object');
  }

  constraints = _lodash2['default'].cloneDeep(constraints); // Defensive copy

  if (skipPresenceConstraint) {
    // Remove the 'presence' constraint if we're not checking for it
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(_lodash2['default'].keys(constraints)), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var key = _step2.value;

        delete constraints[key].presence;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  var validationErrors = _desiredCaps.validator.validate(_lodash2['default'].pickBy(caps, _appiumSupport.util.hasValue), constraints, { fullMessages: false });

  if (validationErrors) {
    var message = [];
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = _getIterator(_lodash2['default'].toPairs(validationErrors)), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _slicedToArray(_step3.value, 2);

        var attribute = _step3$value[0];
        var reasons = _step3$value[1];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = _getIterator(reasons), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var reason = _step4.value;

            message.push('\'' + attribute + '\' ' + reason);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4['return']) {
              _iterator4['return']();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3['return']) {
          _iterator3['return']();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    throw new _protocolErrors.errors.InvalidArgumentError(message.join('; '));
  }

  // Return caps
  return caps;
}

// Standard, non-prefixed capabilities (see https://www.w3.org/TR/webdriver/#dfn-table-of-standard-capabilities)
var STANDARD_CAPS = ['browserName', 'browserVersion', 'platformName', 'acceptInsecureCerts', 'pageLoadStrategy', 'proxy', 'setWindowRect', 'timeouts', 'unhandledPromptBehavior'];

function isStandardCap(cap) {
  return !!_lodash2['default'].find(STANDARD_CAPS, function (standardCap) {
    return standardCap.toLowerCase() === ('' + cap).toLowerCase();
  });
}

// If the 'appium:' prefix was provided and it's a valid capability, strip out the prefix (see https://www.w3.org/TR/webdriver/#dfn-extension-capabilities)
// (NOTE: Method is destructive and mutates contents of caps)
function stripAppiumPrefixes(caps) {
  var prefix = 'appium:';
  var prefixedCaps = _lodash2['default'].filter(_lodash2['default'].keys(caps), function (cap) {
    return ('' + cap).startsWith(prefix);
  });
  var badPrefixedCaps = [];

  // Strip out the 'appium:' prefix
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = _getIterator(prefixedCaps), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var prefixedCap = _step5.value;

      var strippedCapName = prefixedCap.substr(prefix.length);

      // If it's standard capability that was prefixed, add it to an array of incorrectly prefixed capabilities
      if (isStandardCap(strippedCapName)) {
        badPrefixedCaps.push(strippedCapName);
      }

      // Strip out the prefix
      caps[strippedCapName] = caps[prefixedCap];
      delete caps[prefixedCap];
    }

    // If we found standard caps that were incorrectly prefixed, throw an exception (e.g.: don't accept 'appium:platformName', only accept just 'platformName')
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5['return']) {
        _iterator5['return']();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  if (badPrefixedCaps.length > 0) {
    throw new _protocolErrors.errors.InvalidArgumentError('The capabilities ' + JSON.stringify(badPrefixedCaps) + ' are standard capabilities and should not have the "appium:" prefix');
  }
}

/**
 * Get an array of all the unprefixed caps that are being used in 'alwaysMatch' and all of the 'firstMatch' object
 * @param {Object} caps A capabilities object
 */
function findNonPrefixedCaps(_ref) {
  var _ref$alwaysMatch = _ref.alwaysMatch;
  var alwaysMatch = _ref$alwaysMatch === undefined ? {} : _ref$alwaysMatch;
  var _ref$firstMatch = _ref.firstMatch;
  var firstMatch = _ref$firstMatch === undefined ? [] : _ref$firstMatch;

  return _lodash2['default'].chain([alwaysMatch].concat(_toConsumableArray(firstMatch))).reduce(function (unprefixedCaps, caps) {
    return [].concat(_toConsumableArray(unprefixedCaps), _toConsumableArray((0, _lodash2['default'])(caps).keys().filter(function (cap) {
      return !cap.includes(':') && !isStandardCap(cap);
    })));
  }, []).uniq().value();
}

// Parse capabilities (based on https://www.w3.org/TR/webdriver/#processing-capabilities)
function parseCaps(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var shouldValidateCaps = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  // If capabilities request is not an object, return error (#1.1)
  if (!_lodash2['default'].isPlainObject(caps)) {
    throw new _protocolErrors.errors.InvalidArgumentError('The capabilities argument was not valid for the following reason(s): "capabilities" must be a JSON object.');
  }

  // Let 'requiredCaps' be property named 'alwaysMatch' from capabilities request (#2) and 'allFirstMatchCaps' be property named 'firstMatch from capabilities request (#3)
  var _caps$alwaysMatch = // If 'firstMatch' is undefined set it to a singleton list with one empty object (#3.1)
  caps.alwaysMatch;
  var requiredCaps = _caps$alwaysMatch === undefined ? {} : _caps$alwaysMatch;
  var _caps$firstMatch = caps.firstMatch;
  var allFirstMatchCaps = _caps$firstMatch === undefined ? [{}] : _caps$firstMatch;

  // Reject 'firstMatch' argument if it's not an array (#3.2)
  if (!_lodash2['default'].isArray(allFirstMatchCaps)) {
    throw new _protocolErrors.errors.InvalidArgumentError('The capabilities.firstMatch argument was not valid for the following reason(s): "capabilities.firstMatch" must be a JSON array or undefined');
  }

  // If an empty array as provided, we'll be forgiving and make it an array of one empty object
  if (allFirstMatchCaps.length === 0) {
    allFirstMatchCaps.push({});
  }

  // Check for non-prefixed, non-standard capabilities and log warnings if they are found
  var nonPrefixedCaps = findNonPrefixedCaps(caps);
  if (!_lodash2['default'].isEmpty(nonPrefixedCaps)) {
    _logger2['default'].warn('The capabilities ' + JSON.stringify(nonPrefixedCaps) + ' are not standard capabilities and should have an extension prefix');
  }

  // Strip out the 'appium:' prefix from all
  stripAppiumPrefixes(requiredCaps);
  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = _getIterator(allFirstMatchCaps), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var firstMatchCaps = _step6.value;

      stripAppiumPrefixes(firstMatchCaps);
    }

    // Validate the requiredCaps. But don't validate 'presence' because if that constraint fails on 'alwaysMatch' it could still pass on one of the 'firstMatch' keys
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6['return']) {
        _iterator6['return']();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  if (shouldValidateCaps) {
    requiredCaps = validateCaps(requiredCaps, constraints, { skipPresenceConstraint: true });
  }

  // Remove the 'presence' constraint for any keys that are already present in 'requiredCaps'
  // since we know that this constraint has already passed
  var filteredConstraints = _extends({}, constraints);
  var requiredCapsKeys = _lodash2['default'].keys(requiredCaps);
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = _getIterator(_lodash2['default'].keys(filteredConstraints)), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var key = _step7.value;

      if (requiredCapsKeys.includes(key)) {
        delete filteredConstraints[key];
      }
    }

    // Validate all of the first match capabilities and return an array with only the valid caps (see spec #5)
  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7['return']) {
        _iterator7['return']();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  var validationErrors = [];
  var validatedFirstMatchCaps = allFirstMatchCaps.map(function (firstMatchCaps) {
    try {
      // Validate firstMatch caps
      return shouldValidateCaps ? validateCaps(firstMatchCaps, filteredConstraints) : firstMatchCaps;
    } catch (e) {
      validationErrors.push(e.message);
      return null;
    }
  }).filter(function (caps) {
    return !_lodash2['default'].isNull(caps);
  });

  // Try to merge requiredCaps with first match capabilities, break once it finds its first match (see spec #6)
  var matchedCaps = null;
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = _getIterator(validatedFirstMatchCaps), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var firstMatchCaps = _step8.value;

      try {
        matchedCaps = mergeCaps(requiredCaps, firstMatchCaps);
        if (matchedCaps) {
          break;
        }
      } catch (err) {
        _logger2['default'].warn(err.message);
      }
    }

    // Returns variables for testing purposes
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8['return']) {
        _iterator8['return']();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return { requiredCaps: requiredCaps, allFirstMatchCaps: allFirstMatchCaps, validatedFirstMatchCaps: validatedFirstMatchCaps, matchedCaps: matchedCaps, validationErrors: validationErrors };
}

// Calls parseCaps and just returns the matchedCaps variable
function processCapabilities(caps) {
  var constraints = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
  var shouldValidateCaps = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

  var _parseCaps = parseCaps(caps, constraints, shouldValidateCaps);

  var matchedCaps = _parseCaps.matchedCaps;
  var validationErrors = _parseCaps.validationErrors;

  // If we found an error throw an exception
  if (_lodash2['default'].isNull(matchedCaps)) {
    if (_lodash2['default'].isArray(caps.firstMatch) && caps.firstMatch.length > 1) {
      // If there was more than one 'firstMatch' cap, indicate that we couldn't find a matching capabilities set and show all the errors
      throw new _protocolErrors.errors.InvalidArgumentError('Could not find matching capabilities from ' + JSON.stringify(caps) + ':\n ' + validationErrors.join('\n'));
    } else {
      // Otherwise, just show the singular error message
      throw new _protocolErrors.errors.InvalidArgumentError(validationErrors[0]);
    }
  }

  return matchedCaps;
}

exports['default'] = { parseCaps: parseCaps, processCapabilities: processCapabilities, validateCaps: validateCaps, mergeCaps: mergeCaps, findNonPrefixedCaps: findNonPrefixedCaps };
module.exports = exports['default'];
// If 'requiredCaps' is undefined, set it to an empty JSON object (#2.1)
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9iYXNlZHJpdmVyL2NhcGFiaWxpdGllcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBQWMsUUFBUTs7OzsyQkFDSSxnQkFBZ0I7OzZCQUNyQixnQkFBZ0I7O3NCQUNyQixVQUFVOzs7OzhCQUNILG9CQUFvQjs7OztBQUkzQyxTQUFTLFNBQVMsR0FBZ0M7TUFBOUIsT0FBTyx5REFBRyxFQUFFO01BQUUsU0FBUyx5REFBRyxFQUFFOztBQUM5QyxNQUFJLE1BQU0sR0FBRyxlQUFjLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQzs7Ozs7OztBQUV4QyxzQ0FBMEIsb0JBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyw0R0FBRTs7O1VBQXRDLEtBQUk7VUFBRSxLQUFLOzs7QUFFbkIsVUFBSSxDQUFDLG9CQUFFLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSSxDQUFDLENBQUMsRUFBRTtBQUNqQyxjQUFNLElBQUksdUJBQU8sb0JBQW9CLGlCQUFjLEtBQUksNkNBQXVDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLHlCQUFvQixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxjQUFXLENBQUM7T0FDL0s7QUFDRCxZQUFNLENBQUMsS0FBSSxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUQsU0FBTyxNQUFNLENBQUM7Q0FDZjs7O0FBR0QsU0FBUyxZQUFZLENBQUUsSUFBSSxFQUErQjtNQUE3QixXQUFXLHlEQUFHLEVBQUU7TUFBRSxJQUFJLHlEQUFHLEVBQUU7TUFFaEQsc0JBQXNCLEdBQUksSUFBSSxDQUE5QixzQkFBc0I7O0FBRTVCLE1BQUksQ0FBQyxvQkFBRSxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDMUIsVUFBTSxJQUFJLHVCQUFPLG9CQUFvQix5QkFBeUIsQ0FBQztHQUNoRTs7QUFFRCxhQUFXLEdBQUcsb0JBQUUsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDOztB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QztLQUM1RDtHQUNGOztBQUVELFNBQU8sV0FBVyxDQUFDO0NBQ3BCOztxQkFHYyxFQUFFLFNBQVMsRUFBVCxTQUFTLEVBQUUsbUJBQW1CLEVBQW5CLG1CQUFtQixFQUFFLFlBQVksRUFBWixZQUFZLEVBQUUsU0FBUyxFQUFULFNBQVMsRUFBRSxtQkFBbUIsRUFBbkIsbUJBQW1CLEVBQUUiLCJmaWxlIjoibGliL2Jhc2Vkcml2ZXIvY2FwYWJpbGl0aWVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHZhbGlkYXRvciB9IGZyb20gJy4vZGVzaXJlZC1jYXBzJztcbmltcG9ydCB7IHV0aWwgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IGVycm9ycyB9IGZyb20gJy4uL3Byb3RvY29sL2Vycm9ycyc7XG5cbi8vIFRha2VzIHByaW1hcnkgY2FwcyBvYmplY3QgYW5kIG1lcmdlcyBpdCBpbnRvIGEgc2Vjb25kYXJ5IGNhcHMgb2JqZWN0LlxuLy8gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4tbWVyZ2luZy1jYXBhYmlsaXRpZXMpXG5mdW5jdGlvbiBtZXJnZUNhcHMgKHByaW1hcnkgPSB7fSwgc2Vjb25kYXJ5ID0ge30pIHtcbiAgbGV0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIHByaW1hcnkpO1xuXG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgXy50b1BhaXJzKHNlY29uZGFyeSkpIHtcbiAgICAvLyBPdmVyd3JpdGluZyBpcyBub3QgYWxsb3dlZC4gUHJpbWFyeSBhbmQgc2Vjb25kYXJ5IG11c3QgaGF2ZSBkaWZmZXJlbnQgcHJvcGVydGllcyAodzNjIHJ1bGUgNC40KVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmltYXJ5W25hbWVdKSkge1xuICAgICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRFcnJvcihgcHJvcGVydHkgJyR7bmFtZX0nIHNob3VsZCBub3QgZXhpc3Qgb24gYm90aCBwcmltYXJ5ICgke0pTT04uc3RyaW5naWZ5KHByaW1hcnkpfSkgYW5kIHNlY29uZGFyeSAoJHtKU09OLnN0cmluZ2lmeShzZWNvbmRhcnkpfSkgb2JqZWN0YCk7XG4gICAgfVxuICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gVmFsaWRhdGVzIGNhcHMgYWdhaW5zdCBhIHNldCBvZiBjb25zdHJhaW50c1xuZnVuY3Rpb24gdmFsaWRhdGVDYXBzIChjYXBzLCBjb25zdHJhaW50cyA9IHt9LCBvcHRzID0ge30pIHtcblxuICBsZXQgIHtza2lwUHJlc2VuY2VDb25zdHJhaW50fSA9IG9wdHM7XG5cbiAgaWYgKCFfLmlzUGxhaW5PYmplY3QoY2FwcykpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudEVycm9yKGBtdXN0IGJlIGEgSlNPTiBvYmplY3RgKTtcbiAgfVxuXG4gIGNvbnN0cmFpbnRzID0gXy5jbG9uZURlZXAoY29uc3RyYWludHMpOyAvLyBEZWZlbnNpdmUgY29weVxuXG4gIGlmIChza2lwUHJlc2VuY2VDb25zdHJhaW50KSB7XG4gICAgLy8gUmVtb3ZlIHRoZSAncHJlc2VuY2UnIGNvbnN0cmFpbnQgaWYgd2UncmUgbm90IGNoZWNraW5nIGZvciBpdFxuICAgIGZvciAobGV0IGtleSBvZiBfLmtleXMoY29uc3RyYWludHMpKSB7XG4gICAgICBkZWxldGUgY29uc3RyYWludHNba2V5XS5wcmVzZW5jZTtcbiAgICB9XG4gIH1cblxuICBsZXQgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRvci52YWxpZGF0ZShfLnBpY2tCeShjYXBzLCB1dGlsLmhhc1ZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZnVsbE1lc3NhZ2VzOiBmYWxzZX0pO1xuXG4gIGlmICh2YWxpZGF0aW9uRXJyb3JzKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBbXTtcbiAgICBmb3IgKGxldCBbYXR0cmlidXRlLCByZWFzb25zXSBvZiBfLnRvUGFpcnModmFsaWRhdGlvbkVycm9ycykpIHtcbiAgICAgIGZvciAobGV0IHJlYXNvbiBvZiByZWFzb25zKSB7XG4gICAgICAgIG1lc3NhZ2UucHVzaChgJyR7YXR0cmlidXRlfScgJHtyZWFzb259YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IobWVzc2FnZS5qb2luKCc7ICcpKTtcbiAgfVxuXG4gIC8vIFJldHVybiBjYXBzXG4gIHJldHVybiBjYXBzO1xufVxuXG4vLyBTdGFuZGFyZCwgbm9uLXByZWZpeGVkIGNhcGFiaWxpdGllcyAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJkcml2ZXIvI2Rmbi10YWJsZS1vZi1zdGFuZGFyZC1jYXBhYmlsaXRpZXMpXG5jb25zdCBTVEFOREFSRF9DQVBTID0gW1xuICAnYnJvd3Nlck5hbWUnLFxuICAnYnJvd3NlclZlcnNpb24nLFxuICAncGxhdGZvcm1OYW1lJyxcbiAgJ2FjY2VwdEluc2VjdXJlQ2VydHMnLFxuICAncGFnZUxvYWRTdHJhdGVneScsXG4gICdwcm94eScsXG4gICdzZXRXaW5kb3dSZWN0JyxcbiAgJ3RpbWVvdXRzJyxcbiAgJ3VuaGFuZGxlZFByb21wdEJlaGF2aW9yJ1xuXTtcblxuZnVuY3Rpb24gaXNTdGFuZGFyZENhcCAoY2FwKSB7XG4gIHJldHVybiAhIV8uZmluZChTVEFOREFSRF9DQVBTLCAoc3RhbmRhcmRDYXApID0+IHN0YW5kYXJkQ2FwLnRvTG93ZXJDYXNlKCkgPT09IGAke2NhcH1gLnRvTG93ZXJDYXNlKCkpO1xufVxuXG4vLyBJZiB0aGUgJ2FwcGl1bTonIHByZWZpeCB3YXMgcHJvdmlkZWQgYW5kIGl0J3MgYSB2YWxpZCBjYXBhYmlsaXR5LCBzdHJpcCBvdXQgdGhlIHByZWZpeCAoc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJkcml2ZXIvI2Rmbi1leHRlbnNpb24tY2FwYWJpbGl0aWVzKVxuLy8gKE5PVEU6IE1ldGhvZCBpcyBkZXN0cnVjdGl2ZSBhbmQgbXV0YXRlcyBjb250ZW50cyBvZiBjYXBzKVxuZnVuY3Rpb24gc3RyaXBBcHBpdW1QcmVmaXhlcyAoY2Fwcykge1xuICBjb25zdCBwcmVmaXggPSAnYXBwaXVtOic7XG4gIGNvbnN0IHByZWZpeGVkQ2FwcyA9IF8uZmlsdGVyKF8ua2V5cyhjYXBzKSwgY2FwID0+IGAke2NhcH1gLnN0YXJ0c1dpdGgocHJlZml4KSk7XG4gIGNvbnN0IGJhZFByZWZpeGVkQ2FwcyA9IFtdO1xuXG4gIC8vIFN0cmlwIG91dCB0aGUgJ2FwcGl1bTonIHByZWZpeFxuICBmb3IgKGxldCBwcmVmaXhlZENhcCBvZiBwcmVmaXhlZENhcHMpIHtcbiAgICBjb25zdCBzdHJpcHBlZENhcE5hbWUgPSBwcmVmaXhlZENhcC5zdWJzdHIocHJlZml4Lmxlbmd0aCk7XG5cbiAgICAvLyBJZiBpdCdzIHN0YW5kYXJkIGNhcGFiaWxpdHkgdGhhdCB3YXMgcHJlZml4ZWQsIGFkZCBpdCB0byBhbiBhcnJheSBvZiBpbmNvcnJlY3RseSBwcmVmaXhlZCBjYXBhYmlsaXRpZXNcbiAgICBpZiAoaXNTdGFuZGFyZENhcChzdHJpcHBlZENhcE5hbWUpKSB7XG4gICAgICBiYWRQcmVmaXhlZENhcHMucHVzaChzdHJpcHBlZENhcE5hbWUpO1xuICAgIH1cblxuICAgIC8vIFN0cmlwIG91dCB0aGUgcHJlZml4XG4gICAgY2Fwc1tzdHJpcHBlZENhcE5hbWVdID0gY2Fwc1twcmVmaXhlZENhcF07XG4gICAgZGVsZXRlIGNhcHNbcHJlZml4ZWRDYXBdO1xuICB9XG5cbiAgLy8gSWYgd2UgZm91bmQgc3RhbmRhcmQgY2FwcyB0aGF0IHdlcmUgaW5jb3JyZWN0bHkgcHJlZml4ZWQsIHRocm93IGFuIGV4Y2VwdGlvbiAoZS5nLjogZG9uJ3QgYWNjZXB0ICdhcHBpdW06cGxhdGZvcm1OYW1lJywgb25seSBhY2NlcHQganVzdCAncGxhdGZvcm1OYW1lJylcbiAgaWYgKGJhZFByZWZpeGVkQ2Fwcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRFcnJvcihgVGhlIGNhcGFiaWxpdGllcyAke0pTT04uc3RyaW5naWZ5KGJhZFByZWZpeGVkQ2Fwcyl9IGFyZSBzdGFuZGFyZCBjYXBhYmlsaXRpZXMgYW5kIHNob3VsZCBub3QgaGF2ZSB0aGUgXCJhcHBpdW06XCIgcHJlZml4YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2YgYWxsIHRoZSB1bnByZWZpeGVkIGNhcHMgdGhhdCBhcmUgYmVpbmcgdXNlZCBpbiAnYWx3YXlzTWF0Y2gnIGFuZCBhbGwgb2YgdGhlICdmaXJzdE1hdGNoJyBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXBzIEEgY2FwYWJpbGl0aWVzIG9iamVjdFxuICovXG5mdW5jdGlvbiBmaW5kTm9uUHJlZml4ZWRDYXBzICh7YWx3YXlzTWF0Y2g9e30sIGZpcnN0TWF0Y2g9W119KSB7XG4gIHJldHVybiBfLmNoYWluKFthbHdheXNNYXRjaCwgLi4uZmlyc3RNYXRjaF0pXG4gICAgLnJlZHVjZSgodW5wcmVmaXhlZENhcHMsIGNhcHMpID0+IFtcbiAgICAgIC4uLnVucHJlZml4ZWRDYXBzLFxuICAgICAgLi4uXyhjYXBzKS5rZXlzKCkuZmlsdGVyKChjYXApID0+ICFjYXAuaW5jbHVkZXMoJzonKSAmJiAhaXNTdGFuZGFyZENhcChjYXApKSxcbiAgICBdLCBbXSlcbiAgICAudW5pcSgpXG4gICAgLnZhbHVlKCk7XG59XG5cbi8vIFBhcnNlIGNhcGFiaWxpdGllcyAoYmFzZWQgb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRyaXZlci8jcHJvY2Vzc2luZy1jYXBhYmlsaXRpZXMpXG5mdW5jdGlvbiBwYXJzZUNhcHMgKGNhcHMsIGNvbnN0cmFpbnRzID0ge30sIHNob3VsZFZhbGlkYXRlQ2FwcyA9IHRydWUpIHtcbiAgLy8gSWYgY2FwYWJpbGl0aWVzIHJlcXVlc3QgaXMgbm90IGFuIG9iamVjdCwgcmV0dXJuIGVycm9yICgjMS4xKVxuICBpZiAoIV8uaXNQbGFpbk9iamVjdChjYXBzKSkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1RoZSBjYXBhYmlsaXRpZXMgYXJndW1lbnQgd2FzIG5vdCB2YWxpZCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb24ocyk6IFwiY2FwYWJpbGl0aWVzXCIgbXVzdCBiZSBhIEpTT04gb2JqZWN0LicpO1xuICB9XG5cbiAgLy8gTGV0ICdyZXF1aXJlZENhcHMnIGJlIHByb3BlcnR5IG5hbWVkICdhbHdheXNNYXRjaCcgZnJvbSBjYXBhYmlsaXRpZXMgcmVxdWVzdCAoIzIpIGFuZCAnYWxsRmlyc3RNYXRjaENhcHMnIGJlIHByb3BlcnR5IG5hbWVkICdmaXJzdE1hdGNoIGZyb20gY2FwYWJpbGl0aWVzIHJlcXVlc3QgKCMzKVxuICBsZXQge1xuICAgIGFsd2F5c01hdGNoOiByZXF1aXJlZENhcHMgPSB7fSwgLy8gSWYgJ3JlcXVpcmVkQ2FwcycgaXMgdW5kZWZpbmVkLCBzZXQgaXQgdG8gYW4gZW1wdHkgSlNPTiBvYmplY3QgKCMyLjEpXG4gICAgZmlyc3RNYXRjaDogYWxsRmlyc3RNYXRjaENhcHMgPSBbe31dLCAvLyBJZiAnZmlyc3RNYXRjaCcgaXMgdW5kZWZpbmVkIHNldCBpdCB0byBhIHNpbmdsZXRvbiBsaXN0IHdpdGggb25lIGVtcHR5IG9iamVjdCAoIzMuMSlcbiAgfSA9IGNhcHM7XG5cbiAgLy8gUmVqZWN0ICdmaXJzdE1hdGNoJyBhcmd1bWVudCBpZiBpdCdzIG5vdCBhbiBhcnJheSAoIzMuMilcbiAgaWYgKCFfLmlzQXJyYXkoYWxsRmlyc3RNYXRjaENhcHMpKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5JbnZhbGlkQXJndW1lbnRFcnJvcignVGhlIGNhcGFiaWxpdGllcy5maXJzdE1hdGNoIGFyZ3VtZW50IHdhcyBub3QgdmFsaWQgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uKHMpOiBcImNhcGFiaWxpdGllcy5maXJzdE1hdGNoXCIgbXVzdCBiZSBhIEpTT04gYXJyYXkgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICAvLyBJZiBhbiBlbXB0eSBhcnJheSBhcyBwcm92aWRlZCwgd2UnbGwgYmUgZm9yZ2l2aW5nIGFuZCBtYWtlIGl0IGFuIGFycmF5IG9mIG9uZSBlbXB0eSBvYmplY3RcbiAgaWYgKGFsbEZpcnN0TWF0Y2hDYXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbEZpcnN0TWF0Y2hDYXBzLnB1c2goe30pO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIG5vbi1wcmVmaXhlZCwgbm9uLXN0YW5kYXJkIGNhcGFiaWxpdGllcyBhbmQgbG9nIHdhcm5pbmdzIGlmIHRoZXkgYXJlIGZvdW5kXG4gIGxldCBub25QcmVmaXhlZENhcHMgPSBmaW5kTm9uUHJlZml4ZWRDYXBzKGNhcHMpO1xuICBpZiAoIV8uaXNFbXB0eShub25QcmVmaXhlZENhcHMpKSB7XG4gICAgbG9nLndhcm4oYFRoZSBjYXBhYmlsaXRpZXMgJHtKU09OLnN0cmluZ2lmeShub25QcmVmaXhlZENhcHMpfSBhcmUgbm90IHN0YW5kYXJkIGNhcGFiaWxpdGllcyBhbmQgc2hvdWxkIGhhdmUgYW4gZXh0ZW5zaW9uIHByZWZpeGApO1xuICB9XG5cbiAgLy8gU3RyaXAgb3V0IHRoZSAnYXBwaXVtOicgcHJlZml4IGZyb20gYWxsXG4gIHN0cmlwQXBwaXVtUHJlZml4ZXMocmVxdWlyZWRDYXBzKTtcbiAgZm9yIChsZXQgZmlyc3RNYXRjaENhcHMgb2YgYWxsRmlyc3RNYXRjaENhcHMpIHtcbiAgICBzdHJpcEFwcGl1bVByZWZpeGVzKGZpcnN0TWF0Y2hDYXBzKTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRoZSByZXF1aXJlZENhcHMuIEJ1dCBkb24ndCB2YWxpZGF0ZSAncHJlc2VuY2UnIGJlY2F1c2UgaWYgdGhhdCBjb25zdHJhaW50IGZhaWxzIG9uICdhbHdheXNNYXRjaCcgaXQgY291bGQgc3RpbGwgcGFzcyBvbiBvbmUgb2YgdGhlICdmaXJzdE1hdGNoJyBrZXlzXG4gIGlmIChzaG91bGRWYWxpZGF0ZUNhcHMpIHtcbiAgICByZXF1aXJlZENhcHMgPSB2YWxpZGF0ZUNhcHMocmVxdWlyZWRDYXBzLCBjb25zdHJhaW50cywge3NraXBQcmVzZW5jZUNvbnN0cmFpbnQ6IHRydWV9KTtcbiAgfVxuXG5cbiAgLy8gUmVtb3ZlIHRoZSAncHJlc2VuY2UnIGNvbnN0cmFpbnQgZm9yIGFueSBrZXlzIHRoYXQgYXJlIGFscmVhZHkgcHJlc2VudCBpbiAncmVxdWlyZWRDYXBzJ1xuICAvLyBzaW5jZSB3ZSBrbm93IHRoYXQgdGhpcyBjb25zdHJhaW50IGhhcyBhbHJlYWR5IHBhc3NlZFxuICBsZXQgZmlsdGVyZWRDb25zdHJhaW50cyA9IHsuLi5jb25zdHJhaW50c307XG4gIGxldCByZXF1aXJlZENhcHNLZXlzID0gXy5rZXlzKHJlcXVpcmVkQ2Fwcyk7XG4gIGZvciAobGV0IGtleSBvZiBfLmtleXMoZmlsdGVyZWRDb25zdHJhaW50cykpIHtcbiAgICBpZiAocmVxdWlyZWRDYXBzS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBkZWxldGUgZmlsdGVyZWRDb25zdHJhaW50c1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGFsbCBvZiB0aGUgZmlyc3QgbWF0Y2ggY2FwYWJpbGl0aWVzIGFuZCByZXR1cm4gYW4gYXJyYXkgd2l0aCBvbmx5IHRoZSB2YWxpZCBjYXBzIChzZWUgc3BlYyAjNSlcbiAgbGV0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcbiAgbGV0IHZhbGlkYXRlZEZpcnN0TWF0Y2hDYXBzID0gYWxsRmlyc3RNYXRjaENhcHMubWFwKChmaXJzdE1hdGNoQ2FwcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBWYWxpZGF0ZSBmaXJzdE1hdGNoIGNhcHNcbiAgICAgIHJldHVybiBzaG91bGRWYWxpZGF0ZUNhcHMgPyB2YWxpZGF0ZUNhcHMoZmlyc3RNYXRjaENhcHMsIGZpbHRlcmVkQ29uc3RyYWludHMpIDogZmlyc3RNYXRjaENhcHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGUubWVzc2FnZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0pLmZpbHRlcigoY2FwcykgPT4gIV8uaXNOdWxsKGNhcHMpKTtcblxuICAvLyBUcnkgdG8gbWVyZ2UgcmVxdWlyZWRDYXBzIHdpdGggZmlyc3QgbWF0Y2ggY2FwYWJpbGl0aWVzLCBicmVhayBvbmNlIGl0IGZpbmRzIGl0cyBmaXJzdCBtYXRjaCAoc2VlIHNwZWMgIzYpXG4gIGxldCBtYXRjaGVkQ2FwcyA9IG51bGw7XG4gIGZvciAobGV0IGZpcnN0TWF0Y2hDYXBzIG9mIHZhbGlkYXRlZEZpcnN0TWF0Y2hDYXBzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG1hdGNoZWRDYXBzID0gbWVyZ2VDYXBzKHJlcXVpcmVkQ2FwcywgZmlyc3RNYXRjaENhcHMpO1xuICAgICAgaWYgKG1hdGNoZWRDYXBzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgdmFyaWFibGVzIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gIHJldHVybiB7cmVxdWlyZWRDYXBzLCBhbGxGaXJzdE1hdGNoQ2FwcywgdmFsaWRhdGVkRmlyc3RNYXRjaENhcHMsIG1hdGNoZWRDYXBzLCB2YWxpZGF0aW9uRXJyb3JzfTtcbn1cblxuLy8gQ2FsbHMgcGFyc2VDYXBzIGFuZCBqdXN0IHJldHVybnMgdGhlIG1hdGNoZWRDYXBzIHZhcmlhYmxlXG5mdW5jdGlvbiBwcm9jZXNzQ2FwYWJpbGl0aWVzIChjYXBzLCBjb25zdHJhaW50cyA9IHt9LCBzaG91bGRWYWxpZGF0ZUNhcHMgPSB0cnVlKSB7XG4gIGNvbnN0IHttYXRjaGVkQ2FwcywgdmFsaWRhdGlvbkVycm9yc30gPSBwYXJzZUNhcHMoY2FwcywgY29uc3RyYWludHMsIHNob3VsZFZhbGlkYXRlQ2Fwcyk7XG5cbiAgLy8gSWYgd2UgZm91bmQgYW4gZXJyb3IgdGhyb3cgYW4gZXhjZXB0aW9uXG4gIGlmIChfLmlzTnVsbChtYXRjaGVkQ2FwcykpIHtcbiAgICBpZiAoXy5pc0FycmF5KGNhcHMuZmlyc3RNYXRjaCkgJiYgY2Fwcy5maXJzdE1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIElmIHRoZXJlIHdhcyBtb3JlIHRoYW4gb25lICdmaXJzdE1hdGNoJyBjYXAsIGluZGljYXRlIHRoYXQgd2UgY291bGRuJ3QgZmluZCBhIG1hdGNoaW5nIGNhcGFiaWxpdGllcyBzZXQgYW5kIHNob3cgYWxsIHRoZSBlcnJvcnNcbiAgICAgIHRocm93IG5ldyBlcnJvcnMuSW52YWxpZEFyZ3VtZW50RXJyb3IoYENvdWxkIG5vdCBmaW5kIG1hdGNoaW5nIGNhcGFiaWxpdGllcyBmcm9tICR7SlNPTi5zdHJpbmdpZnkoY2Fwcyl9OlxcbiAke3ZhbGlkYXRpb25FcnJvcnMuam9pbignXFxuJyl9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCBzaG93IHRoZSBzaW5ndWxhciBlcnJvciBtZXNzYWdlXG4gICAgICB0aHJvdyBuZXcgZXJyb3JzLkludmFsaWRBcmd1bWVudEVycm9yKHZhbGlkYXRpb25FcnJvcnNbMF0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVkQ2Fwcztcbn1cblxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlQ2FwcywgcHJvY2Vzc0NhcGFiaWxpdGllcywgdmFsaWRhdGVDYXBzLCBtZXJnZUNhcHMsIGZpbmROb25QcmVmaXhlZENhcHMgfTtcbiJdLCJzb3VyY2VSb290IjoiLi4vLi4vLi4ifQ==
